<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2024-04-16T13:39:23+05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Портфолио Sergio Eliofery</title><subtitle>Портфолио и блог Go разработчика Sergio Eliofery.</subtitle><entry><title type="html">Кодогенерация Protobuf файлов используя плагин Buf</title><link href="http://localhost:4000/blog/2024-02-03-kodogeneraciya-protobuf-fajlov-ispolzuya-plagin-buf-backend.html" rel="alternate" type="text/html" title="Кодогенерация Protobuf файлов используя плагин Buf" /><published>2024-02-03T07:00:00+06:00</published><updated>2024-02-03T07:00:00+06:00</updated><id>http://localhost:4000/blog/kodogeneraciya-protobuf-fajlov-ispolzuya-plagin-buf</id><content type="html" xml:base="http://localhost:4000/blog/2024-02-03-kodogeneraciya-protobuf-fajlov-ispolzuya-plagin-buf-backend.html"><![CDATA[<p>В этой статье научимся генерировать <b>Protobuf</b> файлы через плагин <b>Buf</b>. Настроим зависимости сторонних <b>proto</b> нотаций, такие как <b>googleapis</b>, <b>grpc-gateway</b> и <b>protovalidate</b>.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#start">Подготовительные работы</a></li>
  <li><a href="#deps">Установка зависимостей</a></li>
  <li><a href="#api">Структура api</a></li>
  <li><a href="#generate">Генерируем код</a></li>
  <li><a href="#server">Запускаем gRPC и REST сервер</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Данная статья является дополнением предыдущей статьи <a href="/blog/2024-02-01-sozdanie-servera-golang-s-grpc-i-rest-api-ispolzuya-swagger-backend.html" target="_blank">“Создание сервера Golang с gRPC и Rest API используя Swagger”</a>.</p>

<p>В прошлой статье зависимости проекта такие как <strong>google/api/annotations.proto</strong> и т.п. были скачены вручную, здесь же мы разберем как можно улучшить и автоматизировать данный процесс.</p>

<h2 id="start"><span class="attention">Подготовительные</span> работы</h2>

<p>Создадим отправную точку для нашего проекта:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash"># Создание модуля проекта
go mod init github.com/eliofery/golang-buf

# Создание файла команд проекта
touch Makefile</code></pre>
  </div>
</div>

<h3 id="файл-makefile">Файл Makefile</h3>

<p>Содержимое файла <strong>Makefile</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Путь до бинарных файлов
LOCAL_BIN=$(CURDIR)/bin

# Установка бинарных файлов различных пакетов.
# Плагины пакетов можно установить глобально выполнив команду go install [package].
# Но лучше сохранить их в каталоге проекта, зафиксировав используемые версии,
# чтобы не нарушить обратную совместимость при коллективной работе над проектом.
install-bin:
  GOBIN=$(LOCAL_BIN) go install github.com/bufbuild/buf/cmd/buf@v1.29.0
  GOBIN=$(LOCAL_BIN) go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
  GOBIN=$(LOCAL_BIN) go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
  GOBIN=$(LOCAL_BIN) go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@v2.19.1
  GOBIN=$(LOCAL_BIN) go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@v2.19.1

# Приводим проект в первоначальный вид
clean:
  rm -rf $(LOCAL_BIN)</code></pre>
  </div>
</div>

<p>Выполним команду <strong>make install-bin</strong> для скачивания бинарных файлов. В корне проекта создастся каталог <strong>bin</strong> со скаченными бинарниками. Теперь, чтобы вызвать тот или иной плагин в терминале необходимо будет ввести команду <strong>./bin/[имя файла] [опции]</strong>.</p>

<h2 id="deps"><span class="attention">Установка</span> зависимостей</h2>

<p>Для кодогенерации <strong>proto</strong> файлов необходимо наличие <strong>Protobuf</strong> генератора. Подробная инструкция по его установке для различных ОС доступна на <a href="https://grpc.io/docs/protoc-installation" target="_blank" rel="nofollow">официальном сайте</a> <strong>gRPC</strong> документации. Я буду производить установку в <strong>Linux</strong> среде <a href="/blog/2023-08-19-linux-dlya-nachinayushhih-chast-1-ustanovka-linux.html" target="_blank">дистрибутива PopOS!</a>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">// Вариант 1
// Стандартный вариант установки
// Плюсы: ни чего дополнительно устанавливать не надо
// Минусы: устанавливается устаревшая версия
sudo apt update
sudo apt install -y protobuf-compiler

// Вариант 2
// Вариант установки через Snap пакет
// Плюсы: актуальная версия
// Минусы: нужно установить snap
sudo apt update
sudo apt install snapd
sudo snap install protobuf --classic

// Вариант 3
// Вариант со скачиванием бинарного файла
// Скачиваете последнюю версию protobuf с официального репозитория
// https://github.com/protocolbuffers/protobuf/releases
// И добавьте путь до бинарного файла protobuf в переменные среды,
// либо разместите бинарный файл в каталоге /usr/local/bin
// Плюсы: актуальная версия
// Минусы: сложность установки

// Для проверки работоспособности вводим команду
protoc --version</code></pre>
  </div>
</div>

<p>В предыдущем разделе мы скачали бинарники необходимых нам пакетов. Теперь необходимо так же скачать сами пакеты. При установке пакетов задаем конкретные версии для сохранения совместимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go get google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go get google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@v2.19.1
go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@v2.19.1
go get github.com/bufbuild/protovalidate-go@v0.6.0</code></pre>
  </div>
</div>

<h2 id="api"><span class="attention">Структура</span> api</h2>

<p>Официальная <a href="https://buf.build/docs/introduction" target="_blank" rel="nofollow">документация Buf</a> предоставляет подробное описание того как должна выглядеть структура <strong>proto</strong> файлов и описание <strong>buf</strong> конфигураций. Советую ознакомиться:</p>

<ul>
  <li><a href="https://buf.build/docs/reference/workspaces" target="_blank" rel="nofollow">Организация нескольких модулей</a></li>
  <li><a href="https://buf.build/docs/best-practices/style-guide" target="_blank" rel="nofollow">Стайл гайд</a></li>
  <li><a href="https://buf.build/docs/configuration/v1/buf-yaml" target="_blank" rel="nofollow">buf.yaml</a></li>
  <li><a href="https://buf.build/docs/configuration/v1/buf-gen-yaml" target="_blank" rel="nofollow">buf.gen.yaml</a></li>
  <li><a href="https://buf.build/docs/configuration/v1/buf-work-yaml" target="_blank" rel="nofollow">buf.work.yaml</a></li>
</ul>

<p>Следуя выше изложенной документации создадим в корне проекта файлы <strong>buf.gen.yaml</strong> и <strong>buf.work.yaml</strong>.</p>

<p><strong>buf.gen.yaml</strong> - конфигурационный файл содержит правила для генерации кода из <strong>proto</strong> файлов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BUF.GEN.YAML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="buf.gen.yaml">version: v1

# Настройки используемых плагинов.
# Здесь мы перечисляем скаченные раннее бинарные файлы плагинов,
# указываем путь где размещать сгенерированные .go файлы
# и прописываем различные дополнительные опции.
plugins:
  # Генерирует файлы .pb.go
  - name: go
    path: ./bin/protoc-gen-go
    out: ./pkg
    opt:
    - paths=source_relative

  # Генерирует файлы _grpc.pb.go
  - name: go-grpc
    path: ./bin/protoc-gen-go-grpc
    out: ./pkg
    opt:
    - paths=source_relative

  # Генерирует файлы .pb.gw.go
  - name: grpc-gateway
    path: ./bin/protoc-gen-grpc-gateway
    out: ./pkg
    opt:
    - paths=source_relative

  # Генерирует файлы .swagger.json
  - name: openapiv2
    path: ./bin/protoc-gen-openapiv2
    out: ./pkg

  # Генерирует один общий файл .swagger.json
  - name: openapiv2
    path: ./bin/protoc-gen-openapiv2
    out: ./docs
    opt:
    - allow_merge=true</code></pre>
  </div>
</div>

<p><strong>buf.work.yaml</strong> - конфигурационный файл содержит перечень директорий в которых хранятся <strong>proto</strong> файлы.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BUF.GEN.YAML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="buf.gen.yaml">version: v1

# Перечисление директорий, хранящих .proto файлы
directories:
  - api</code></pre>
  </div>
</div>

<p>В корне проекта создадим каталог <strong>api</strong> в котором будут располагаться все пользовательские <strong>proto</strong> файлы. Внутри каталога <strong>api</strong> создадим файл <strong>buf.yaml</strong>.</p>

<p><strong>buf.yaml</strong> - конфигурационный файл содержит различные настройки такие как линтер, зависимости, исключаемые из генерации <strong>proto</strong> файлы и много другое.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BUF.YAML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="buf.yaml">version: v1

# Зависимости проекта
deps:
  - buf.build/googleapis/googleapis
  - buf.build/grpc-ecosystem/grpc-gateway
  - buf.build/bufbuild/protovalidate

# Базовые настройки линтера для proto файлов
lint:
  use:
    - DEFAULT

# Не вникал в этот параметр, но оставил его, так как он автоматически прописывается
# при создании файла buf.yaml через команду ./bin/buf mod init.
breaking:
  use:
    - FILE</code></pre>
  </div>
</div>

<p>После описания <strong>buf.yaml</strong> файла необходимо установить прописанные в нем зависимости, выполнив команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash"># api - название директории, где хранится файл buf.yaml.
# Если команда buf mod update вызывается из каталога, где находится файл buf.yaml, то имя директории можно не писать.
./bin/buf mod update api</code></pre>
  </div>
</div>

<p>После выполнения команды в <strong>Buf cache</strong> будут установлены прописанные зависимости и мы сможем воспользоваться их <strong>proto</strong> файлами. Далее мы на практике это рассмотрим. Так же рядом с файлом <strong>buf.yaml</strong> появится файл <strong>buf.lock</strong> который хранит именно те версии зависимостей, что мы установили. Это нужно опять же для обратной совместимости при командной работе.</p>

<p>И так, конфигурационные <strong>buf</strong> файлы настроены настала пора создать структуру наших <strong>proto</strong> файлов. Для этого в каталоге <strong>api</strong> создадим каталог, хранящий <strong>proto</strong> файлы. Я назову его <strong>microservice</strong>.</p>

<p>При развитии проекта бывает необходимость в кардинальном изменении <strong>API</strong>. В этом случае поможет версионирование <strong>proto</strong> файлов. Для этого внутри каталога <strong>microservice</strong> создадим каталог <strong>v1</strong>. В нем будут храниться <strong>proto</strong> файлы относящиеся к <strong>API</strong> первой версии. В каталоге <strong>v1</strong> создадим два файла <strong>microservice_grpc.proto</strong> и <strong>user.proto</strong>.</p>

<ul>
  <li><strong>microservice_grpc.proto</strong> - будет описывать <strong>service</strong>, хранящий <strong>rpc</strong> ручки.</li>
  <li><strong>user.proto</strong> - будет описывать <strong>message</strong>, хранищий сущности запроса, ответа нашего <strong>API</strong> для пользователей.</li>
</ul>

<p>Каждая сущность описывается в своем <strong>proto</strong> файле, <strong>например</strong>: product.proto, payment.proto, upload.proto и т.п.<br />
А файл <strong>microservice_grpc.proto</strong> их агрегирует.</p>

<p>Более подробное объяснение описания <strong>proto</strong> файлов было в прошлой статье, здесь я лишь коснусь кратко некоторых моментов.</p>

<h3 id="файл-microservice_grpcproto">Файл microservice_grpc.proto</h3>

<p>Опишем содержимое файла <strong>microservice_grpc.proto</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MICROSERVICE_GRPC.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="microservice_grpc.proto">syntax = "proto3";

package microservice.v1;

option go_package = "github.com/eliofery/golang-fullstack/pkg/microservice/v1";

import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

import "microservice/v1/user.proto";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Echo API";
    version: "1.0";
    description: "";
    contact: {
      name: "gRPC-Gateway project";
      url: "https://github.com/grpc-ecosystem/grpc-gateway";
      email: "none@example.com";
    };
    license: {
      name: "BSD 3-Clause License";
      url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
    };
  };
  schemes: HTTPS;
  consumes: "application/json";
  produces: "application/json";
};

service MicroService {
  rpc User(UserRequest) returns (UserResponse) {
    option (google.api.http) = {
        post: "/v1/user"
        body: "*"
    };

    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
        summary: "Get a message.";
        operation_id: "getMessage";
        tags: "echo";
        responses: {
            key: "201"
            value: {
                description: "OK Success";
            }
        }
    };
  }
}</code></pre>
  </div>
</div>

<p>В данном файле мы импортируем файлы <strong>google/api/annotations.proto</strong> и <strong>protoc-gen-openapiv2/options/annotations.proto</strong>. Мы можем воспользоваться ими благодаря тому, что установили зависимости, прописанные в файле <strong>buf.yaml</strong>, используя команду <strong>./bin/buf mod update api</strong>.</p>

<h3 id="файл-userproto">Файл user.proto</h3>

<p>Опишем содержимое файла <strong>user.proto</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">USER.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="user.proto">syntax = "proto3";

package microservice.v1;

option go_package = "github.com/eliofery/golang-fullstack/pkg/microservice/v1";

import "protoc-gen-openapiv2/options/annotations.proto";
import "buf/validate/validate.proto";
import "google/protobuf/wrappers.proto";

message UserRequest {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
    json_schema: {
      title: "A bit of everything"
      description: "Intentionaly complicated message type to cover many features of Protobuf."
      required: ["number", "email", "password"]
    }
    external_docs: {
      url: "https://github.com/grpc-ecosystem/grpc-gateway";
      description: "Find out more about ABitOfEverything";
    }
    example: "{\"number\": \"538\",\"email\": \"test@mail.org\",\"password\": \"123456\"}"
  };

  int32 number = 1;
  string email = 2 [
      (buf.validate.field).string.email = true
  ];
}

message UserResponse {
  google.protobuf.StringValue result = 1;
}</code></pre>
  </div>
</div>

<p>В данном файле мы импортируем файлы <strong>protoc-gen-openapiv2/options/annotations.proto</strong> и <strong>buf/validate/validate.proto</strong>. Возможность использовать эти <strong>proto</strong> файлы так же доступно благодаря установки зависимостей прописанных в файле <strong>buf.yaml</strong>.</p>

<h3 id="версия-2">Версия 2</h3>

<p>Скопируем каталог <strong>v1</strong> со всеми файлами в ту же директорию и переименуем его в <strong>v2</strong>.</p>

<p>Содержимое файлов <strong>microservice_grpc.proto</strong> и <strong>user.proto</strong> будет следующим:</p>

<h4 id="microservice_grpcproto">microservice_grpc.proto</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MICROSERVICE_GRPC.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="microservice_grpc.proto">syntax = "proto3";

package microservice.v2;

option go_package = "github.com/eliofery/golang-fullstack/pkg/microservice/v2";

import "google/api/annotations.proto";

import "microservice/v2/user.proto";

service MicroService {
  rpc User(UserRequest) returns (UserResponse) {
    option (google.api.http) = {
      post: "/v2/user"
      body: "*"
    };
  }
}</code></pre>
  </div>
</div>

<h4 id="userproto">user.proto</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">USER.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="user.proto">syntax = "proto3";

package microservice.v2;

option go_package = "github.com/eliofery/golang-fullstack/pkg/microservice/v2";

import "buf/validate/validate.proto";
import "google/protobuf/wrappers.proto";

message UserRequest {
    int32 number = 1;
    string email = 2 [
        (buf.validate.field).string.email = true
    ];
}

message UserResponse {
    google.protobuf.StringValue result = 1;
}</code></pre>
  </div>
</div>

<h2 id="generate"><span class="attention">Генерируем</span> код</h2>

<p>Перед тем как сгенерировать код из <strong>proto</strong> файлов давайте проверим соответствие наших <strong>proto</strong> файлов правилам линтера. Для это воспользуемся командой:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">buf lint</code></pre>
  </div>
</div>

<p>При возникновении ошибок линтер подскажет, что не так. В нашем случае ошибок быть не должно и мы можем приступить к генерации кода:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">buf generate</code></pre>
  </div>
</div>

<p>После выполнения команды в корне проекта появятся два каталога <strong>docs</strong>, хранящий <strong>Swagger</strong> файл с нашим <strong>API</strong> и <strong>pkg</strong> сгенерированные <strong>Protobuf</strong> файлы.</p>

<p>Ваш <strong>IDE</strong> может подсвечивать красным цветом сторонние зависимости <strong>proto</strong> файлов. Если вы пользуетесь <strong>IDE Goland</strong> то установите плагин <strong>Buf for Protocol Buffers</strong> для других редакторов ознакомьтесь с <a href="https://github.com/bufbuild/buf/issues/493#issuecomment-947090008" target="_blank" rel="nofollow">этим обсуждением</a> возможно оно вам поможет.</p>

<h2 id="server"><span class="attention">Запускаем</span> gRPC и REST сервер</h2>

<p>В корне проекта создадим каталог <strong>cmd/grpc_server</strong> и внутри него файл <strong>main.go</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">package main

import (
  "context"
  "fmt"
  pb "github.com/eliofery/golang-fullstack/pkg/microservice/v1"
  pbV2 "github.com/eliofery/golang-fullstack/pkg/microservice/v2"
  "github.com/golang/protobuf/ptypes/wrappers"
  "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
  "google.golang.org/grpc"
  "google.golang.org/grpc/reflection"
  "net"
  "net/http"
)

type MicroserviceServer struct {
  pb.UnimplementedMicroServiceServer
}

func (s *MicroserviceServer) User(ctx context.Context, req *pb.UserRequest) (*pb.UserResponse, error) {
  return &amp;pb.UserResponse{
    Result: &amp;wrappers.StringValue{Value: "success"},
  }, nil
}

type MicroserviceV2Server struct {
  pbV2.UnimplementedMicroServiceServer
}

func (s *MicroserviceV2Server) User(ctx context.Context, req *pbV2.UserRequest) (*pbV2.UserResponse, error) {
  return &amp;pbV2.UserResponse{
    Result: &amp;wrappers.StringValue{Value: "success v2"},
  }, nil
}

func main() {
  ch := make(chan error, 2)
  
  // gRPC server
  go func(ch chan error) {
    fmt.Println("gRPC server start :50051")
    listen, err := net.Listen("tcp", ":50051")
    if err != nil {
      ch &lt;- err
    }
  
    grpcServer := grpc.NewServer()
    reflection.Register(grpcServer)
    
    pb.RegisterMicroServiceServer(grpcServer, &amp;MicroserviceServer{})
    pbV2.RegisterMicroServiceServer(grpcServer, &amp;MicroserviceV2Server{})
    
    if err = grpcServer.Serve(listen); err != nil {
      ch &lt;- err
    }
  }(ch)
  
  // REST server
  go func() {
    mux := runtime.NewServeMux()

    err := pb.RegisterMicroServiceHandlerServer(context.Background(), mux, &amp;MicroserviceServer{})
    if err != nil {
      ch &lt;- err
    }

    err = pbV2.RegisterMicroServiceHandlerServer(context.Background(), mux, &amp;MicroserviceV2Server{})
    if err != nil {
      ch &lt;- err
    }
  
    server := http.Server{
      Addr:    ":8080",
      Handler: mux,
    }
    
    fmt.Println("REST server start :8080")
    if err = server.ListenAndServe(); err != nil {
      ch &lt;- err
    }
  }()
  
  for i := 0; i &lt; 2; i++ {
    if err := &lt;-ch; err != nil {
      panic(err)
    }
  }
}</code></pre>
  </div>
</div>

<p>Мы уже разбирали этот код в <a href="/blog/2024-02-01-sozdanie-servera-golang-s-grpc-i-rest-api-ispolzuya-swagger-backend.html" target="_blank">прошлой статье</a>, здесь я лишь добавил использование <strong>API</strong> версии первой и второй.</p>

<p>Для этого нужно зарегистрировать каждую версию нашего <strong>API</strong> после чего оно станет доступно по заданному адресу и порту:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">// pb - сокращенно от protobuf
import (
  pb "github.com/eliofery/golang-fullstack/pkg/microservice/v1"
  pbV2 "github.com/eliofery/golang-fullstack/pkg/microservice/v2"
)

type MicroserviceServer struct {
  pb.UnimplementedMicroServiceServer
}

type MicroserviceV2Server struct {
  pbV2.UnimplementedMicroServiceServer
}

pb.RegisterMicroServiceServer(grpcServer, &amp;MicroserviceServer{})
pbV2.RegisterMicroServiceServer(grpcServer, &amp;MicroserviceV2Server{})

pb.RegisterMicroServiceHandlerServer(context.Background(), mux, &amp;MicroserviceServer{})
pbV2.RegisterMicroServiceHandlerServer(context.Background(), mux, &amp;MicroserviceV2Server{})</code></pre>
  </div>
</div>

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>В этой статье мы расширили свои знания в области генерации <strong>proto</strong> кода используя плагин <strong>Buf</strong>. Данный вариант считается передовым и рекомендуемым по сравнению с предыдущим, который мы разбирали в прошлой статье. Хотя он тоже довольно не плох. Какой из этих подходов выбирать решайте сами.</p>

<h3 id="ссылки-на-проект">Ссылки на проект</h3>

<ul>
  <li><a href="#golang-buf" target="_blank" rel="nofollow">Исходный код</a></li>
</ul>]]></content><author><name></name></author><category term="backend" /><category term="golang" /><category term="gRPC" /><category term="googleapis" /><category term="grpc-gateway" /><category term="protovalidate" /><category term="protobuf" /><category term="buf" /><summary type="html"><![CDATA[В этой статье научимся генерировать Protobuf файлы через плагин Buf. Настроим зависимости сторонних proto нотаций, такие как googleapis, grpc-gateway и protovalidate.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Создание сервера Golang с gRPC и Rest API используя Swagger</title><link href="http://localhost:4000/blog/2024-02-01-sozdanie-servera-golang-s-grpc-i-rest-api-ispolzuya-swagger-backend.html" rel="alternate" type="text/html" title="Создание сервера Golang с gRPC и Rest API используя Swagger" /><published>2024-02-01T07:00:00+06:00</published><updated>2024-02-01T07:00:00+06:00</updated><id>http://localhost:4000/blog/sozdanie-servera-golang-s-grpc-i-rest-api-ispolzuya-swagger</id><content type="html" xml:base="http://localhost:4000/blog/2024-02-01-sozdanie-servera-golang-s-grpc-i-rest-api-ispolzuya-swagger-backend.html"><![CDATA[<p>В этой статье затронем такие темы как <b>gRPC</b>, <b>Rest API</b>, <b>Swagger</b>, <b>Protobuf</b>, <b>валидация данных</b> и создадим веб сервер используя эти технологии.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#start">Подготовительные работы</a></li>
  <li><a href="#protobuf">Протокол Protobuf</a></li>
  <li><a href="#grpc">Фреймворк gRPC</a></li>
  <li><a href="#gateway">Плагин gRPC-Gateway</a></li>
  <li><a href="#proto">Описываем proto файлы</a></li>
  <li><a href="#generate">Генерируем код</a></li>
  <li><a href="#validate">Валидация данных</a></li>
  <li><a href="#swagger">OpenAPI (Swagger)</a></li>
  <li><a href="#buf">Плагин Buf</a></li>
  <li><a href="#server">Запускаем gRPC и REST сервер</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>В сфере веб-разработки существует несколько стратегий взаимодействия с клиентами. Одни из самых распространенных это <strong>gRPC</strong> и <strong>REST API</strong>. В нашей статье мы сосредоточимся на создании сервера на <strong>Golang</strong>, который способен обслуживать оба этих метода взаимодействия с клиентами. Кроме того, мы рассмотрим использование <strong>Swagger</strong> для создания документации и проведения тестирования нашего <strong>API</strong>.</p>

<h2 id="start"><span class="attention">Подготовительные</span> работы</h2>

<p>Создадим отправную точку для нашего проекта:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash"># Создание модуля проекта
go mod init github.com/eliofery/golang-grpc

# Создание исполняемого файла
mkdir -p cmd/grpc &amp;&amp; touch cmd/grpc/main.go

# Создание файла настроек редактора
touch .editorconfig

# Создание файла .gitignore
touch .gitignore

# Создание файла настроек для пакета modd
touch modd.conf

# Создание файла команд проекта
touch Makefile</code></pre>
  </div>
</div>

<h3 id="файл-maingo">Файл main.go</h3>

<p>Содержимое файла <strong>main.go</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">package main

func main() {
  // code
}</code></pre>
  </div>
</div>

<h3 id="файл-editorconfig">Файл .editorconfig</h3>

<p>Содержимое файла <strong>.editorconfig</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.EDITORCONFIG</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".editorconfig">root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
end_of_line = lf
trim_trailing_whitespace = true
insert_final_newline = true

[*.{yml,yaml}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false</code></pre>
  </div>
</div>

<h3 id="файл-gitignore">Файл .gitignore</h3>

<p>Содержимое файла <strong>.gitignore</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.GITIGNORE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".gitignore">.idea
bin</code></pre>
  </div>
</div>

<h3 id="файл-makefile">Файл Makefile</h3>

<p>Содержимое файла <strong>Makefile</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Автоматическая сборка проекта при изменении файлов
watch:
  modd

# Сборка проекта
build:
  go build -o bin/grpc cmd/grpc/main.go</code></pre>
  </div>
</div>

<h3 id="файл-moddconf">Файл modd.conf</h3>

<p><strong>Modd</strong> позволяет автоматически компилировать <strong>Golang</strong> проект при изменении файлов, более подробно об этой возможности была <a href="/blog/2024-01-21-avtomaticheskaya-kompilyaciya-golang-proekta-pri-izmenenii-fajlov-backend.html" target="_blank">статья</a> ранее.</p>

<p>Содержимое файла <strong>modd.conf</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MODD.CONF</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="modd.conf"># https://github.com/cortesi/modd
# go install github.com/cortesi/modd/cmd/modd@latest

# Проверка всех тестов при первой запуске
**/*.go {
  prep: go test @dirmods
}

# Автоматическая компиляция проекта при изменении файлов
# Исключает все тестовые файлы *_test.go
**/*.go !**/*_test.go {
  prep: go build -o ./bin/grpc ./cmd/grpc/main.go
  daemon +sigterm: ./bin/grpc
}</code></pre>
  </div>
</div>

<h2 id="protobuf"><span class="attention">Протокол</span> Protobuf</h2>

<p>Протокол буферизации сообщений <strong>Protobuf</strong> представляет собой мощный инструмент для сериализации структурированных данных, который широко используется в различных областях разработки программного обеспечения. Созданный в <strong>Google</strong>, <strong>Protobuf</strong> обеспечивает эффективную передачу данных между приложениями, облегчая процесс коммуникации и сокращая размер передаваемых сообщений.</p>

<p>Ознакомиться с данным протоколом можно на <a href="https://protobuf.dev/getting-started/gotutorial" target="_blank" rel="nofollow">официальном сайте</a> документации <strong>Protobuf</strong>.</p>

<p>Для использования <strong>Protobuf</strong> необходимо его установить, инструкция по установке доступна на <a href="https://grpc.io/docs/protoc-installation" target="_blank" rel="nofollow">официальном сайте</a> <strong>gRPC</strong> документации.</p>

<p>Устанавливать <strong>Protobuf</strong> я буду на <strong>Linux</strong> дистрибутив <strong>PopOS!</strong>, поэтому приведенные примеры будут касаться среды <strong>Linux</strong>. Если вы пользуетесь <strong>Windows</strong> или <strong>Mac</strong>, то поищите примеры установки самостоятельно, например в выше изложенной документации. Кстати в блоге есть <a href="/blog/2023-08-19-linux-dlya-nachinayushhih-chast-1-ustanovka-linux.html" target="_blank">серия статей</a> про работу с дистрибутивом <strong>PopOS!</strong> с уклоном в веб разработку.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">// Стандартный вариант установки
// Плюсы: ни чего дополнительно устанавливать не надо
// Минусы: устанавливается устаревшая версия
sudo apt update
sudo apt install -y protobuf-compiler

// Вариант установки через Snap пакет
// Плюсы: актуальная версия
// Минусы: нужно установить snap
sudo apt update
sudo apt install snapd
sudo snap install protobuf --classic

// Вариант со скачиванием бинарного файла
// Скачиваете последнюю версию protobuf с официального репозитория
// https://github.com/protocolbuffers/protobuf/releases
// И добавьте путь до бинарного файла protobuf в переменные среды,
// либо разместите бинарный файл в каталоге /usr/local/bin
// Плюсы: актуальная версия
// Минусы: сложность установки

// Для проверки работоспособности вводим команду
protoc --version</code></pre>
  </div>
</div>

<p>При успешной установке должна отобразиться текущая версия <strong>protobuf</strong>, например: <strong>libprotoc 3.14.0</strong>.</p>

<h2 id="grpc"><span class="attention">Фреймворк</span> gRPC</h2>

<p><strong>gRPC</strong> — это современная высокопроизводительная платформа от компании <strong>Google</strong>, основанная на протоколе удаленного вызова процедур <strong>RPC</strong>. <strong>gRPC</strong> использует <strong>Protocol Buffers (protobuf)</strong> и <strong>HTTP2</strong>.</p>

<p>Выше мы провели подготовительные действия для работы с <strong>Protobuf</strong> настала пора установить плагины <strong>gRPC</strong> и <strong>protobuf</strong>. Более подробное описание по установке доступно на <a href="https://grpc.io/docs/languages/go/quickstart" target="_blank" rel="nofollow">официальном сайте</a>.</p>

<p>Вводим в терминале следующие команды:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go get google.golang.org/protobuf/cmd/protoc-gen-go
go get google.golang.org/grpc/cmd/protoc-gen-go-grpc

go install google.golang.org/protobuf/cmd/protoc-gen-go
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</code></pre>
  </div>
</div>

<p><strong>protoc-gen-go</strong> - это плагин для компилятора <strong>Protobuf</strong> файлов с расширением <strong>protoc</strong>, который генерирует <strong>Golang</strong> код на основе определений сообщений и сервисов, написанных на языке <strong>protobuf</strong>. Позволяет создавать эффективный и легко читаемый код на <strong>Golang</strong> для работы с данными, определенными в файлах <strong>Protobuf</strong>.</p>

<p><strong>protoc-gen-go-grpc</strong> - это плагин также является частью инструментария <strong>Protobuf</strong> и предназначен для генерации кода на <strong>Golang</strong> для реализации <strong>gRPC</strong> серверов и клиентов. Он расширяет функциональность <strong>protoc-gen-go</strong>, добавляя возможность генерации кода для обработки <strong>RPC</strong> (удаленных процедурного вызова) с использованием протокола <strong>gRPC</strong>.</p>

<h2 id="gateway"><span class="attention">Плагин</span> gRPC-Gateway</h2>

<p>На данный момент <strong>фронтенд</strong> напрямую не умеет взаимодействовать с <strong>gRPC</strong> сервером, но его можно подружить благодаря <strong>gRPC-Gateway</strong> плагину. <strong>gRPC-Gateway</strong> считывает определение службы <strong>gRPC</strong> и создает обратный прокси-сервер, который преобразует <strong>Rest API</strong> в <strong>gRPC</strong>.</p>

<p>Более подробно ознакомиться с этим плагином можно на его <a href="https://grpc-ecosystem.github.io/grpc-gateway" target="_blank" rel="nofollow">официальном сайте</a>.</p>

<p>Для установки <strong>gRPC-Gateway</strong> вводим в терминале следующие команды:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway

go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway</code></pre>
  </div>
</div>

<p><strong>protoc-gen-grpc-gateway</strong> - это инструмент позволяет генерировать код на <strong>Golang</strong> для обработки <strong>HTTP</strong> запросов к <strong>gRPC</strong> серверу. Он автоматически создает обработчики <strong>HTTP</strong>, которые преобразуют входящие запросы в вызовы <strong>RPC</strong> и обратно, что облегчает создание <strong>Rest API</strong> на основе существующего <strong>gRPC API</strong>. Это удобно для клиентов, которые предпочитают взаимодействовать с сервером через <strong>HTTP</strong>, а также для интеграции с существующими веб-инфраструктурами.</p>

<h2 id="proto"><span class="attention">Описываем</span> proto файлы</h2>

<p>После подготовительных работ, связанных с установкой необходимых пакетов и плагинов настала пора приступить к созданию и описанию <strong>proto</strong> файлов.</p>

<p>В корне проекта создадим следующие каталоги:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">mkdir -p api/microservice/v1</code></pre>
  </div>
</div>

<p>В каталоге <strong>api</strong> будет храниться описание нашего <strong>Api</strong> в виде <strong>proto</strong> файлов. Каталог <strong>microservice</strong> название нашего сервиса, можете придумать свое название и <strong>v1</strong> версия нашего <strong>Api</strong>.</p>

<p>Внутри каталога <strong>v1</strong> создадим два файла:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">touch api/microservice/v1/microservice.proto
touch api/microservice/v1/example.proto</code></pre>
  </div>
</div>

<p>В файле <strong>microservice.proto</strong> будут храниться “ручки”, <strong>rpc</strong> правила взаимодействия клиент-сервера.</p>

<p>В файле <strong>example.proto</strong> описываются данные которые должны быть получены и отправлены при запросе, ответе.</p>

<p>Для каждой созданной “ручки” в файле <strong>microservice.proto</strong> необходимо будет создавать отдельный файл описывающий данные запроса и ответа, по аналогии с файлом <strong>example.proto</strong>. Можно было бы все описать в файле <strong>microservice.proto</strong>, но для наглядности и удобства лучше разделить <strong>rpc</strong> от <strong>message</strong>. Главное не забывать импортировать файлы с описанием запроса и ответа в файл <strong>microservice.proto</strong>, например <strong>import “microservice/v1/example.proto”;</strong>.</p>

<p>Опишем содержимое файла <strong>example.proto</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">EXAMPLE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="example.proto">// Указываем используемую версию нотации protobuf
syntax = "proto3";

// Имя нашего пакета по аналогии с .go файлами
// В названии пакета дублируем путь до самого файла proto, исключая название родительской директории (api)
// и изменяя слэш (/) точкой (.), пример:
// microservice/v1 -&gt; microservice.v1
package microservice.v1;

// Файл proto это всего лишь описательная нотация, некий чертеж на основе которого
// необходимо сформировать программный код.
// Этой строкой указывается путь до каталога где будут размещены сгенерированные **Golang** файлы.
// Обратите внимание, что путь начинается с название нашего пакета, того самого которое мы задали при выполнении
// команды go mod init github.com/eliofery/golang-grpc, далее идут названия самих каталогов
option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v1";

// Запрос
// Описываем структуру данных которые планируем получить от клиента.
// Для понимания что к чему относится важно добавлять окончание Request к названию структуры.
message ExampleRequest {
  int32 number = 1;
}

// Ответ
// Описываем структуру данных которые планируем отправить клиенту.
// Для понимания что к чему относится важно добавлять окончание Response к названию структуры.
message ExampleResponse {
  string result = 1;
}</code></pre>
  </div>
</div>

<p>Опишем содержимое файла <strong>microservice.proto</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MICROSERVICE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="microservice.proto">syntax = "proto3";

package microservice.v1;

option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v1";

// Импортируем annotations.proto который необходим, чтобы описать rpc в rest нотации,
// для того, чтобы в дальнейшем можно было создать rest на основе rpc
import "google/api/annotations.proto";

// В файле example.proto мы создали пользовательские message ExampleRequest и ExampleResponse.
// Существуют подобные структуры которые Google описал за нас, ниже можно увидеть импорт
// часто используемых protobuf нотаций.

// empty.proto используется если необходимо получить или вернуть ни чего, например:
// rpc Example(google.protobuf.Empty) returns (google.protobuf.Empty)
// import "google/protobuf/empty.proto";

// timestamp.proto описывает тип данных, связанный с временем
// google.protobuf.Timestamp
// import "google/protobuf/timestamp.proto";

// Импортируем наш пользовательский message, созданный выше
import "microservice/v1/example.proto";

// Описываем наш api сервис
service Microservice {
  // Создаем "ручку", которая принимает данные описанные в ExampleRequest
  // и возвращает данные описанные в ExampleResponse
  rpc Example(ExampleRequest) returns (ExampleResponse) {
    // Это описание для Rest API, которое доступно благодаря annotations.proto
    option (google.api.http) = {
      // Ожидается POST запрос по адресу /example
      post: "/v1/example"
      // Тело запроса, может быть любым
      body: "*"
    };
  }
}</code></pre>
  </div>
</div>

<p>Можно заметить, что <strong>import “google/api/annotations.proto”;</strong> подсвечивается красным цветом в <strong>IDE</strong>. Так как редактор не может найти этот файл. Чтобы это исправить необходимо скачать нужный нам <strong>annotations.proto</strong> из <a href="https://github.com/googleapis/googleapis/tree/master/google/api" target="_blank" rel="nofollow">репозитория Google</a>, а вместе с ним еще и <strong>http.proto</strong>, так как <strong>annotations.proto</strong> использует его внутри своего описания.</p>

<p>Чтобы скачать эти файлы, откроем <strong>Makefile</strong> и добавим в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Скачивание proto google
proto-google:
  curl https://raw.githubusercontent.com/googleapis/googleapis/974ad5bdfc9ba768db16b3eda2850aadd8c10a2c/google/api/annotations.proto --create-dirs -o api/google/api/annotations.proto
  curl https://raw.githubusercontent.com/googleapis/googleapis/974ad5bdfc9ba768db16b3eda2850aadd8c10a2c/google/api/http.proto --create-dirs -o api/google/api/http.proto</code></pre>
  </div>
</div>

<p>Данные файлы находятся в <a href="https://github.com/googleapis/googleapis/tree/master/google/api" target="_blank" rel="nofollow">репозитории Google</a>.</p>

<p>Выполним в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">make proto-google</code></pre>
  </div>
</div>

<p>Внутри каталога <strong>api</strong> будет создан каталог <strong>google/api</strong> с двумя файлами <strong>annotations.proto</strong> и <strong>http.proto</strong>.</p>

<p>Я использую <strong>IDE Goland</strong> если оно продолжает подсвечивать красным цветом нотацию <strong>import “google/api/annotations.proto”;</strong> нажмите горячие клавиши <kbd>Ctrl + Alt + S</kbd>. Откроется раздел настроек, перейдите в раздел <strong>Languages &amp; Frameworks</strong> далее в <strong>Protocol Buffers</strong> и в разделе <strong>Imports Paths</strong> измените путь так чтобы <strong>IDE</strong> смотрело в каталог <strong>api</strong>, например: <strong>home/eliofery/www/github/golang-grpc/api</strong>.</p>

<p>Теперь <strong>IDE</strong> должен успешно подхватить все файлы <strong>proto</strong> и мы можем приступить к генерации кода.</p>

<h2 id="generate"><span class="attention">Генерируем</span> код</h2>

<p>Вспомним что в каждом нашем <strong>proto</strong> файле мы прописывали конструкцию <strong>option go_package = “github.com/eliofery/golang-grpc/pkg/microservice/v1”;</strong>. Это путь куда будет генерироваться программный код нашего <strong>Api</strong> из описания <strong>proto</strong> файлов.</p>

<p>Для того чтобы сгенерировать программный код, откроем файл <strong>Makefile</strong> и добавим в него следующие команды:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Название пакета
PACKAGE=$(shell awk 'NR==1 {print $$2}' go.mod)

# Генерация кода
generate:
  protoc -Iapi \
    --go_opt=module=$(PACKAGE) --go_out=. \
    --go-grpc_opt=module=$(PACKAGE) --go-grpc_out=. \
    --grpc-gateway_opt=module=$(PACKAGE) --grpc-gateway_out=. \
    api/microservice/v1/*.proto</code></pre>
  </div>
</div>

<p>Рассмотрим подробнее, что здесь происходит.</p>

<p><strong>PACKAGE=$(shell awk ‘NR==1 {print $$2}’ go.mod)</strong> - данная строчка при запуске любой команды в <strong>Makefile</strong> создаст переменную в которую положит результат выполнения команды <strong>shell awk ‘NR==1 {print $$2}’ go.mod</strong>. Данная команда прочитает файл <strong>go.mod</strong> и возьмет из него название модуля, в данном случае у меня это будет <strong>github.com/eliofery/golang-grpc</strong>. Данное значение пригодится при генерировании <strong>proto</strong> файлов в <strong>go</strong> код.</p>

<p><strong>protoc -Iapi</strong> - запускаем плагин <strong>protoc</strong> который генерирует нотацию <strong>proto</strong> в программный код, <strong>-Iapi</strong> указываем путь до родительского каталога где хранятся наши <strong>proto</strong> файлы. Так же можно было бы прописать <strong>--proto_path=api</strong> более наглядный вид. Если появится еще какой-нибудь каталог с <strong>proto</strong> файлами, его так же можно добавить, например: <strong>-Iapi -Ifoobar</strong>.</p>

<p><strong>--go_opt=module=$(PACKAGE) --go_out=.</strong> - сгенерирует файлы <strong>microservice.pb.go</strong>, <strong>example.pb.go</strong> и разместит их по пути указанном в <strong>option go_package = “github.com/eliofery/golang-grpc/pkg/microservice/v1”;</strong>. Часть <strong>PACKAGE</strong>, которая равно <strong>github.com/eliofery/golang-grpc</strong> будет откинута из <strong>option go_package</strong> останется только цепочка каталогов куда будет размещен сгенерированный файл, в нашем случе это каталог <strong>pkg/microservice/v1</strong> в корне проекта. Каталоги будут автоматически созданы при их отсутствии.</p>

<p><strong>--go-grpc_opt=module=$(PACKAGE) --go-grpc_out=.</strong> - по аналогии с <strong>--go_opt</strong> будет создан файл <strong>microservice_grpc.pb.go</strong>.</p>

<p><strong>--grpc-gateway_opt=module=$(PACKAGE) --grpc-gateway_out=.</strong> - по аналогии с <strong>--go_opt</strong> будет создан файл <strong>microservice.pb.gw.go</strong>.</p>

<p><strong>api/microservice/v1/*.proto</strong> - указываем путь до файлов <strong>proto</strong> которые будут генерироваться в код.</p>

<p>Все сгенерированные файлы нужны будут в дальнейшем для написания логики веб сервера.</p>

<p>Выполним в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">make generate</code></pre>
  </div>
</div>

<p>Как видим создалась следующая структура:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">pkg/
└── microservice
    └── v1
        ├── example.pb.go
        ├── microservice_grpc.pb.go
        ├── microservice.pb.go
        └── microservice.pb.gw.go</code></pre>
  </div>
</div>

<h2 id="validate"><span class="attention">Валидация</span> данных</h2>

<p>При получении данных от клиента необходимо их провалидировать, в целях безопасности, да и в целом хороший тон получать то, что ожидаешь.</p>

<p>Для этого воспользуемся готовой <strong>proto</strong> нотацией <a href="https://github.com/bufbuild/protovalidate" target="_blank" rel="nofollow">библиотеки protovalidate</a>. Скачаем ее уже знакомым нам способом, как это делали с <strong>Google</strong> <strong>proto</strong> файлами.</p>

<p>Добавим в <strong>Makefile</strong> новое правило:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Скачивание proto validate
proto-validate:
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/validate.proto --create-dirs -o api/buf/validate/validate.proto
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/expression.proto --create-dirs -o api/buf/validate/expression.proto
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/priv/private.proto --create-dirs -o api/buf/validate/priv/private.proto</code></pre>
  </div>
</div>

<p>Выполним в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">make proto-validate</code></pre>
  </div>
</div>

<p>Внутри каталога <strong>api</strong> будет создан каталог <strong>buf/validate</strong> с файлами <strong>validate.proto</strong>, <strong>expression.proto</strong> и <strong>priv/private.proto</strong>.</p>

<p>С примерами использования <strong>protovalidate</strong> можно ознакомиться на <a href="https://github.com/bufbuild/protovalidate/tree/main/examples" target="_blank" rel="nofollow">этой странице</a>.</p>

<p>Откроем файл <strong>example.proto</strong> и добавим в структуру сообщения, импорт <strong>validate.proto</strong> и два поля с описанием валидации:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">EXAMPLE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="example.proto">import "buf/validate/validate.proto";

message ExampleRequest {
  int32 number = 1;
  string email = 2 [(buf.validate.field).string.email = true];
  string password = 3 [(buf.validate.field).string = {min_len: 8, max_len: 20}];
}</code></pre>
  </div>
</div>

<p>Описание валидации происходит добавлением конструкции <strong>[(buf.validate.field)]</strong>, далее через цепочку значений указывается тип <strong>(.string)</strong> и правило валидации <strong>(.email)</strong>. При вводе <strong>IDE</strong> подсказывает доступные варианты, можно лишний раз не лезть в документацию или исходный код.</p>

<p>После описания <strong>proto</strong> файла напишем тестовый код который продемонстрирует работу валидатора. Но перед этим установим еще один пакет, который будет валидировать данные:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go get github.com/bufbuild/protovalidate-go</code></pre>
  </div>
</div>

<p>Откроем файл <strong>cmd/grpc/main.go</strong> и добавим в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">package main

import (
  "fmt"
  "github.com/bufbuild/protovalidate-go"
  pb "github.com/eliofery/golang-grpc/pkg/microservice/v1"
)

func main() {
  req := pb.ExampleRequest{
    Number: 42,
    Email: "test@mail.example",
    Password: "password",
  }

  v, err := protovalidate.New()
  if err != nil {
    fmt.Println("не удалось инициализировать валидатор:", err)
  }

  if err = v.Validate(&amp;req); err != nil {
    fmt.Println("проверка не удалась:", err)
  } else {
    fmt.Println("проверка прошла успешно")
  }
}</code></pre>
  </div>
</div>

<p>Вызовем команду в терминале <strong>make generate &amp;&amp; make build</strong>, запустим скомпилированный файл <strong>bin/grpc</strong> и получим сообщение <strong>проверка прошла успешно</strong>. При не корректном <strong>email</strong> либо <strong>password</strong> выведется примерно следующее сообщение об ошибке: <strong>проверка не удалась: validation error: - email: value must be a valid email address [string.email]</strong>.</p>

<h2 id="swagger"><span class="attention">OpenAPI</span> (Swagger)</h2>

<p><strong>OpenAPI (бывший Swagger)</strong> — инструмент для разработки веб-сервисов, который позволяет описывать, создавать, консолидировать и визуализировать <strong>API</strong>. С его помощью разработчики могут создавать и поддерживать актуальную документацию к своим <strong>API</strong>, а также тестировать и отлаживать их.</p>

<p>Для установки <strong>Openapiv2</strong> вводим в терминале следующие команды:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2

go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2</code></pre>
  </div>
</div>

<p><strong>protoc-gen-openapiv2</strong> - это инструмент генерирует файлы <strong>OpenAPI</strong> (ранее известные как <strong>Swagger</strong>) на основе определений <strong>gRPC</strong> сервисов. <strong>OpenAPI</strong> - это спецификация для описания <strong>Rest API</strong>, которая облегчает документирование и взаимодействие с <strong>API</strong>. Используя <strong>protoc-gen-openapiv2</strong>, разработчики могут автоматически создавать файлы <strong>OpenAPI</strong> для своих <strong>gRPC</strong> сервисов, что позволяет легко создавать документацию и выполнять различные операции тестирования и проверки соответствия.</p>

<p>Для генерации откроем файл <strong>Makefile</strong> и отредактируем содержимое команды <strong>generate</strong> следующим образом:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Генерация кода
generate:
  mkdir -p pkg/microservice/v1
  protoc -Iapi \
    --go_opt=module=$(PACKAGE) --go_out=. \
    --go-grpc_opt=module=$(PACKAGE) --go-grpc_out=. \
    --grpc-gateway_opt=module=$(PACKAGE) --grpc-gateway_out=. \
    --openapiv2_out=allow_merge=true:./pkg/microservice/v1 \
    api/microservice/v1/*.proto</code></pre>
  </div>
</div>

<p>И так, первым делом мы создаем каталог <strong>pkg/microservice/v1</strong>, в котором будут размещены все сгенерированные файлы. К их числу прибавится файл <strong>apidocs.swagger.json</strong>, содержащий схему нашего <strong>API</strong> на основе <strong>gRPC</strong> сервиса <strong>Microservice</strong>. Команда <strong>allow_merge=true</strong> означает, что все файлы <strong>proto</strong> будут объеденины в один общий файл <strong>apidocs.swagger.json</strong> и размещены по пути <strong>./pkg/microservice/v1</strong>.</p>

<p>Чтобы посмотреть сгенерированную <strong>Swagger</strong> схему в графическом, удобном виде нужно будет установить некоторые <strong>Docker</strong> образы. Для этого у вас должен быть установлен сам <strong>Docker</strong>. В блоге была <a href="/blog/2023-08-21-linux-dlya-nachinayushhih-chast-3-soft-dlya-povsednevnyh-zadach-linux.html#docker" target="_blank">статья по установке Docker</a> в среде <strong>Linux</strong>.</p>

<p>В корне проекта создадим файл <strong>docker-compose.yml</strong> c следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">DOCKER-COMPOSE.YML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="docker-compose.yml">version: "3.9"

services:
  swagger-editor:
    image: swaggerapi/swagger-editor
    container_name: "swagger-editor-container"
    ports:
      - "8085:8080"

  swagger-ui:
    image: swaggerapi/swagger-ui
    container_name: "swagger-ui-container"
    ports:
      - "8086:8080"
  volumes:
    - ./pkg/microservice/v1/apidocs.swagger.json:/v1.swagger.json
    - ./pkg/microservice/v2/apidocs.swagger.json:/v2.swagger.json
  environment:
    SWAGGER_JSON: /v1.swagger.json
    URLS: "[
      { url: 'v1.swagger.json', name: 'API Version 1.0'},
      { url: 'v2.swagger.json', name: 'API Version 2.0'},
    ]"</code></pre>
  </div>
</div>

<p>В сервисе <strong>swagger-ui</strong> добавили версию <strong>API 2.0</strong> с заделом на будущее, позже мы его создадим. Параметр <strong>SWAGGER_JSON</strong> используется для выбора, прописанного в нем <strong>API</strong> при загрузке интерфейса <strong>Swagger</strong> в браузере. Параметр <strong>URLS</strong> позволяет переключаться в графическом интерфейсе браузера, между доступными версиями <strong>API</strong>.</p>

<p>Запустим прописанные в файле <strong>docker-compose.yml</strong> сервисы:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">docker compose up -d</code></pre>
  </div>
</div>

<p>Будут подняты два виртуальных сервера по ссылкам <strong>http://localhost:8085</strong> и <strong>http://localhost:8086</strong>.</p>

<p>На порту <strong>8085</strong> будет располагаться редактор <strong>Swagger</strong> схемы куда можно будет скопировать содержимое файла <strong>apidocs.swagger.json</strong> и редактировать его в реальном времени.</p>

<p>На порту <strong>8086</strong> будет располагаться сама наша документация, прописанная в файле <strong>apidocs.swagger.json</strong>, где мы можем ознакомиться с ней в наглядном виде.</p>

<p>В целом автоматическая генерация <strong>API</strong> посредством <strong>Swagger</strong> на основании <strong>protobuf</strong> файлов готова, но можно ее сделать еще более информативной. Чтобы этого достичь нужно скачать <strong>proto</strong> файлы пакета <strong>protoc-gen-openapiv2</strong>, по аналогии с файлами <strong>Google</strong> и <strong>Validate</strong>.</p>

<p>Откроем файл <strong>Makefile</strong> и добавим в него новую команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Скачивание proto openapiv2
proto-openapiv2:
  curl https://raw.githubusercontent.com/grpc-ecosystem/grpc-gateway/main/protoc-gen-openapiv2/options/annotations.proto --create-dirs -o api/protoc-gen-openapiv2/options/annotations.proto
  curl https://raw.githubusercontent.com/grpc-ecosystem/grpc-gateway/main/protoc-gen-openapiv2/options/openapiv2.proto --create-dirs -o api/protoc-gen-openapiv2/options/openapiv2.proto</code></pre>
  </div>
</div>

<p>Выполним команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">make proto-openapiv2</code></pre>
  </div>
</div>

<p>Создастся каталог <strong>api/protoc-gen-openapiv2</strong> со всему нужными нам <strong>proto</strong> файлами для детального описания <strong>Swagger</strong> документации. Откроем скаченный файл <strong>openapiv2.proto</strong>, в нем в комментариях отображены примеры того как можно описывать наше <strong>API</strong>. Я не буду застрять на этом внимание так как примеры довольно интуитивно понятны. Приступим сразу к реализации.</p>

<p>Откроем файл <strong>microservice.proto</strong> хранящий <strong>rpc</strong> нотации и добавим туда примеры из файла <strong>openapiv2.proto</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MICROSERVICE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="microservice.proto">syntax = "proto3";

package microservice.v1;

option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v1";

// Импорт нотации openapiv2
import "protoc-gen-openapiv2/options/annotations.proto";

import "google/api/annotations.proto";
//import "google/protobuf/empty.proto";
//import "google/protobuf/timestamp.proto";

import "microservice/v1/example.proto";

// Основное описание API
option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Echo API";
    version: "1.0";
    description: "";
    contact: {
      name: "gRPC-Gateway project";
      url: "https://github.com/grpc-ecosystem/grpc-gateway";
      email: "none@example.com";
    };
    license: {
      name: "BSD 3-Clause License";
      url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE";
    };
  };
  schemes: HTTPS;
  consumes: "application/json";
  produces: "application/json";
};

service Microservice {
  rpc Example(ExampleRequest) returns (ExampleResponse) {
    option (google.api.http) = {
      post: "/v1/example"
      body: "*"
    };

    // Описание для POST запроса /v1/example
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "Get a message.";
      operation_id: "getMessage";
      tags: "echo";
      responses: {
        key: "201"
        value: {
          description: "OK Success";
        }
      }
    };
  }
}</code></pre>
  </div>
</div>

<p>Я не буду подробно описывать каждую конструкцию так как при просмотре <strong>API</strong> в браузере все становится понятно и вы легко сможете разобраться в каких местах документации выводится тот или иной текст и изменить его под свои нужды. В файле <strong>openapiv2.proto</strong> так же имеются ссылки на документацию, где все эти правила досконально расписаны, загляните туда, чтобы ознакомиться с дополнительными возможностями.</p>

<p>Отредактируем так же файл <strong>example.proto</strong>, хранящий сообщения запроса и ответа, пример так же был взят из файла <strong>openapiv2.proto</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">EXAMPLE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="example.proto">syntax = "proto3";

package microservice.v1;

option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v1";

// Импорт нотации openapiv2
import "protoc-gen-openapiv2/options/annotations.proto";
import "buf/validate/validate.proto";

message ExampleRequest {
    // Детальное описание запроса ExampleRequest в Swagger
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
        json_schema: {
            title: "A bit of everything"
            description: "Intentionaly complicated message type to cover many features of Protobuf."
            required: ["number", "email", "password"]
        }
        external_docs: {
            url: "https://github.com/grpc-ecosystem/grpc-gateway";
            description: "Find out more about ABitOfEverything";
        }
        example: "{\"number\": \"538\",\"email\": \"test@mail.org\",\"password\": \"123456\"}"
    };

    // Описываем детально поля
    int32 number = 1 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
        description: "The number of the simple message."
    }];
    string email = 2 [
        (buf.validate.field).string.email = true,
        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
            description: "The email of the simple message."
        }
    ];
    string password = 3 [
        (buf.validate.field).string = {min_len: 8, max_len: 20},
        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
            description: "The password of the simple message."
        }
    ];
}

message ExampleResponse {
    string result = 1;
}</code></pre>
  </div>
</div>

<p>Вот таким довольно интересным способом можно подробно описать весь <strong>API</strong>.</p>

<h2 id="buf"><span class="attention">Плагин</span> Buf</h2>

<p>Перед тем как речь пойдем о <strong>Buf</strong> подредактируем файл <strong>Makefile</strong>.</p>

<p>На данный момент, чтобы полностью собрать наш проект необходимо выполнить поочередно команды в терминале:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">make google-proto
make proto-validate
make proto-openapiv2
make generate
docker compose down &amp;&amp; docker compose up -d
make build</code></pre>
  </div>
</div>

<p>Что не совсем удобно. Хорошо было бы собирать и приводить весь проект в исходное состояние одной командой. Для достижения этой цели отредактируем файл <strong>Makefile</strong> следующим образом:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Название пакета
PACKAGE=$(shell awk 'NR==1 {print $$2}' go.mod)

# Автоматическая сборка проекта при изменении файлов
watch:
  modd

# Сборка проекта
build:
  make clean
  make proto-google &amp;&amp; make proto-validate &amp;&amp; make proto-openapiv2
  make generate
  docker compose down &amp;&amp; docker compose up -d
  make bin

# Создание бинарника
bin:
  go build -o bin/grpc cmd/grpc/main.go

# Скачивание proto google
google-proto:
  curl https://raw.githubusercontent.com/googleapis/googleapis/974ad5bdfc9ba768db16b3eda2850aadd8c10a2c/google/api/annotations.proto --create-dirs -o api/google/api/annotations.proto
  curl https://raw.githubusercontent.com/googleapis/googleapis/974ad5bdfc9ba768db16b3eda2850aadd8c10a2c/google/api/http.proto --create-dirs -o api/google/api/http.proto

# Скачивание proto validate
proto-validate:
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/validate.proto --create-dirs -o api/buf/validate/validate.proto
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/expression.proto --create-dirs -o api/buf/validate/expression.proto
  curl https://raw.githubusercontent.com/bufbuild/protovalidate/main/proto/protovalidate/buf/validate/priv/private.proto --create-dirs -o api/buf/validate/priv/private.proto

# Скачивание proto openapiv2
proto-openapiv2:
  curl https://raw.githubusercontent.com/grpc-ecosystem/grpc-gateway/main/protoc-gen-openapiv2/options/annotations.proto --create-dirs -o api/protoc-gen-openapiv2/options/annotations.proto
  curl https://raw.githubusercontent.com/grpc-ecosystem/grpc-gateway/main/protoc-gen-openapiv2/options/openapiv2.proto --create-dirs -o api/protoc-gen-openapiv2/options/openapiv2.proto

# Генерация кода
generate:
  mkdir -p pkg/microservice/v1
  protoc -Iapi \
    --go_opt=module=$(PACKAGE) --go_out=. \
    --go-grpc_opt=module=$(PACKAGE) --go-grpc_out=. \
    --grpc-gateway_opt=module=$(PACKAGE) --grpc-gateway_out=. \
    --openapiv2_out=allow_merge=true:./pkg/microservice/v1 \
    api/microservice/v1/*.proto

# Очистка проекта
clean:
  rm -rf bin
  rm -rf pkg/microservice
  rm -rf api/buf
  rm -rf api/google
  rm -rf api/protoc-gen-openapiv2</code></pre>
  </div>
</div>

<p>Теперь сборка проекта происходит командой <strong>make build</strong>, а возврат в исходное состояние командой <strong>make clean</strong>.</p>

<p><strong>Плагин Buf</strong> - позволяет на основе заданных правил в конфигурационном файле <strong>buf.gen.yml</strong> генерировать <strong>proto</strong> файлы в программный <strong>Golang</strong> код. По сути он выполняет туже самую работу которую мы только, что описывали в файле <strong>Makefile</strong> для генерации кода, но делает это в более удобной и наглядной форме. Предоставляя при этом различные дополнительные фишки, которые мы не будем касаться в рамках этой статьи.</p>

<p>Подробная официальная документация по установке <strong>Buf</strong> доступна по <a href="https://buf.build/docs/installation" target="_blank" rel="nofollow">следующей ссылке</a>. Я же воспользуюсь командами:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go install github.com/bufbuild/buf/cmd/buf</code></pre>
  </div>
</div>

<p>Выше было упомянуто, что плагин <strong>Buf</strong> генерирует <strong>Golang</strong> по прописанным правилам в конфигурационном файле <strong>buf.gen.yml</strong>. Более подробное объяснение вы можете найти в <a href="https://buf.build/docs/generate/tutorial" target="_blank" rel="nofollow">официальной документации</a>.</p>

<p>И так, создадим в каталоге <strong>api</strong> файл <strong>buf.gen.yml</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BUF.GEN.YML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="buf.gen.yml"># Версия нотации Buf
version: v1

# Перечень запускаемых плагинов
plugins:
  # Настройки плагина protoc-gen-go
  # Аналог записи в Makefile: --go_opt=module=$(PACKAGE) --go_out=.
  # name - название плагина
  # out - путь до каталога куда буду сохранены сгенерированные файлы
  # opt - перечисление опций данного плагина
  - name: go
    out: ../pkg
    opt:
      - paths=source_relative

  # Настройки плагина protoc-gen-go-grpc
  # Аналог записи в Makefile: --go-grpc_opt=module=$(PACKAGE) --go-grpc_out=.
  - name: go-grpc
    out: ../pkg
    opt:
      - paths=source_relative

  # Настройки плагина protoc-gen-grpc-gateway
  # Аналог записи в Makefile: --grpc-gateway_opt=module=$(PACKAGE) --grpc-gateway_out=.
  - name: grpc-gateway
    out: ../pkg
    opt:
      - paths=source_relative</code></pre>
  </div>
</div>

<p>Если взглянуть на описание команды <strong>generate</strong> в файле <strong>Makefile</strong>, то там так же было добавлено правило <strong>–openapiv2_out=allow_merge=true:./pkg/microservice/v1</strong>. Оно кардинально отличается от правил описанных выше <strong>--go_opt, --go-grpc_opt и т.д.</strong> Дело в том, что почему-то разработчики плагина <strong>protoc-gen-openapiv2</strong> не добавили правило <strong>--openapiv2_opt</strong> из-за чего пришлось хардкодить конечный путь генерации файла <strong>Swagger</strong> документации.</p>

<p>Мы бы могли в файле <strong>buf.gen.yml</strong> ниже остальных описаний так же добавить <strong>openapiv2</strong>, но это не было бы гибким решением при условии, что у нашего <strong>API</strong> когда-нибудь появится еще одна версия, например <strong>V2</strong>, а затем <strong>V3</strong>. Лучшем решением, было бы иметь возможность использовать правило <strong>--openapiv2_opt</strong>, но как говорилось ранее нам его не завезли.</p>

<p>В общем, возможно тот пример который я вам приведу покажется кастыльным, но лучшего решения я пока не придумал. Для того чтобы иметь возможность генерировать разные файлы <strong>apidocs.swagger.json</strong> для каждой версии <strong>API</strong>, создадим внутри каталога <strong>api/microservice/v1</strong> еще один файл <strong>buf.gen.yml</strong> и пропишем в него:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BUF.GEN.YML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="buf.gen.yml">version: v1

plugins:
  - name: openapiv2
    out: ../pkg/microservice/v1
    opt:
      - allow_merge=true</code></pre>
  </div>
</div>

<p>Иными словами мы вынесли настройки плагина <strong>openapiv2</strong> в отдельный файл под конкретною версию <strong>API</strong>. Теперь в будущем если у нас появится новая версия апи <strong>microservice/v2</strong> мы сможем внутри файла <strong>buf.gen.yml</strong> для каждой версии <strong>API</strong> прописать свои настройки.</p>

<p>Для более наглядного примера продублируем каталог <strong>microservice/v1</strong> и назовем его <strong>microservice/v2</strong>. Файл <strong>microservice/v2/example.proto</strong> переименуем в <strong>user.proto</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">USER.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="user.proto">syntax = "proto3";

package microservice.v2;

option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v2";

message UserRequest {
  string name = 1;
}

message UserResponse {
  int32 age = 1;
}</code></pre>
  </div>
</div>

<p>А содержимое файла <strong>microservice/v2/microservice.proto</strong> изменим на:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MICROSERVICE.PROTO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="microservice.proto">syntax = "proto3";

package microservice.v2;

option go_package = "github.com/eliofery/golang-grpc/pkg/microservice/v2";

import "google/api/annotations.proto";
import "microservice/v2/user.proto";

service Microservice {
  rpc User(UserRequest) returns (UserResponse) {
    option (google.api.http) = {
      get: "/v2/user"
    };
  }
}</code></pre>
  </div>
</div>

<p>Здесь я уже не стал добавлять <strong>Swagger</strong> нотацию описания документации, так как это не тема данного раздела, но если хотите, можете сделать это самостоятельно.</p>

<p>На данный момент мы имеем две версии <strong>API V1</strong> и <strong>V2</strong>. Опишем в файле <strong>Makefile</strong> вызов плагина <strong>Buf</strong> для генерации <strong>proto</strong> в <strong>go</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAKEFILE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="Makefile"># Сборка проекта через Buf
buf:
  make clean
  make proto-google &amp;&amp; make proto-validate &amp;&amp; make proto-openapiv2
  make generate-buf
  docker compose down &amp;&amp; docker compose up -d
  make bin

# Генерация кода через Buf
V1=microservice/v1
V2=microservice/v2
generate-buf:
  cd ./api \
  &amp;&amp; buf generate --template buf.gen.yml --path $(V1) \
    &amp;&amp; buf generate --template $(V1)/buf.gen.yml --path $(V1) \
  &amp;&amp; buf generate --template buf.gen.yml --path $(V2) \
    &amp;&amp; buf generate --template $(V2)/buf.gen.yml --path $(V2)</code></pre>
  </div>
</div>

<p>Мы создаем отдельные переменные для каждой версии <strong>API</strong>, хранящие путь к <strong>proto</strong> файлам. Можно относиться к ним как к <strong>$(PACKAGE)</strong> в команде <strong>generate</strong>. Далее мы переходим в каталог <strong>api</strong> и внутри него генерируем сперва файл <strong>buf.gen.yml</strong> затем генерируем файл <strong>microservice/v1/buf.gen.yml</strong>. Аналогичным образом проделываем это для <strong>API V2</strong>.</p>

<p>Далее в файле <strong>docker-compose.yml</strong> в параметр <strong>volumes</strong> и <strong>URLS</strong> необходимо добавить новые версии <strong>API</strong>, чтобы они подхватились <strong>Swagger</strong> документацией.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">DOCKER-COMPOSE.YML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="docker-compose.yml">swagger-ui:
  image: swaggerapi/swagger-ui
  container_name: "swagger-ui-container"
  ports:
    - "8086:8080"
  volumes:
    - ./pkg/microservice/v1/apidocs.swagger.json:/v1.swagger.json
    - ./pkg/microservice/v2/apidocs.swagger.json:/v2.swagger.json
  environment:
    SWAGGER_JSON: /v1.swagger.json
    URLS: "[
      {url: 'v1.swagger.json', name: 'API Version 1.0'},
      {url: 'v2.swagger.json', name: 'API Version 2.0'},
    ]"</code></pre>
  </div>
</div>

<p>Выполним команду <strong>make buf</strong> в терминале, для того чтобы заново скачать и сгенерировать все файлы, а так же перезапустить виртуальный сервер <strong>Swagger</strong>. Теперь если перейти по ссылке <a href="http://localhost:8086/" target="_blank" rel="nofollow">localhost:8086</a> в правом верхнем углу отобразится выпадающее меню с выбором доступных версий <strong>API</strong>.</p>

<h2 id="server"><span class="attention">Запускаем</span> gRPC и REST сервер</h2>

<p>Перед тем как начать писать код запуска <strong>gRPC</strong> и <strong>REST</strong> серверов приведем наши зависимости в порядок выполнив команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">go mod tidy</code></pre>
  </div>
</div>

<p>Теперь файлы <strong>go.mod</strong> и <strong>go.sum</strong> стали заметно чище.</p>

<p>Откроем файл <strong>cmd/grpc/main.go</strong>, пример с валидацией данных нам не понадобится поэтому я полностью перепишу логику в данном файле.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">package main

import (
  "context"
  "fmt"
  pb "github.com/eliofery/golang-grpc/pkg/microservice/v1"
  "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
  "google.golang.org/grpc"
  "google.golang.org/grpc/reflection"
  "net"
  "net/http"
)

// Создаем структуру, которая будет реализовывать rpc ручки, прописанные в файле microservice.proto.
// При генерации кода был создан файл microservice_grpc.pb.go, где описан MicroserviceServer interface который содержит,
// необходимые для реализации методы. Так же имеется UnimplementedMicroserviceServer struct, которая содержит реализацию
// методов, прописанных в MicroserviceServer interface. Описание методов в UnimplementedMicroserviceServer struct носит
// информационный характер в котором говорится что метод еще не реализован. Это нужно для того, чтобы сервер не паниковал,
// если какой-либо метод не реализован.
// И того, если нужно чтобы все методы строго были реализованы используйте MicroserviceServer interface иначе
// UnimplementedMicroserviceServer struct.
// Я буду использовать UnimplementedMicroserviceServer, чтобы не ждать когда логика всех методов будет реализована.
type MicroserviceServer struct {
  //pb.MicroserviceServer
  pb.UnimplementedMicroserviceServer
}

// Описываем реализацию метода Example, который является нашей rpc ручкой в файле microservice.proto.
// Откроем файл microservice_grpc.pb.go, найдем MicroserviceServer interface и скопируем все содержимое метода
// Example(context.Context, *ExampleRequest) (*ExampleResponse, error).
// Далее создадим реализацию метода Example для структуры MicroserviceServer, описанной выше.
func (s *MicroserviceServer) Example(ctx context.Context, req *pb.ExampleRequest) (*pb.ExampleResponse, error) {
  fmt.Println("Example rpc")

  // Получаем данные запроса от клиента
  data := pb.ExampleRequest{
    Number:   req.GetNumber(),
    Email:    req.GetEmail(),
    Password: req.GetPassword(),
  }

  // Некая бизнес логика
  _ = data

  // Возвращаем данные ответа от сервера
  return &amp;pb.ExampleResponse{
    Result: "success",
  }, nil
}

func main() {
  // Создаем неблокирующий канал с буфером равным 2.
  // Сделано это, для того чтобы запустить сервер gRPC и REST в отдельных друг от друга горутинах.
  // И чтобы горутины не блокировали друг друга, а работали параллельно.
  ch := make(chan error, 2)

  // gRPC сервер
  go func(ch chan error) {
    // Создаем tcp соединение на порту 50051
    fmt.Println("gRPC server start :50051")
    listen, err := net.Listen("tcp", ":50051")
    if err != nil {
      ch &lt;- err
    }

    // Создаем gRPC сервер
    grpcServer := grpc.NewServer()

    // Получаем все методы gRPC сервера. Нужно для того, чтобы программы для работы с API
    // на подобии Postman, без дополнительного импорта proto файлов знали какие методы доступны.
    reflection.Register(grpcServer)

    // Данная функция была сгенерирована в файле microservice_grpc.pb.go.
    // Она подвязывает к gRPC серверу структуру которая реализовывает логику rpc ручек.
    // Иначе говоря Handler (обработчики) по аналогии как это происходит в REST реализации.
    pb.RegisterMicroserviceServer(grpcServer, &amp;MicroserviceServer{})

    // Запускаем gRPC сервер
    if err = grpcServer.Serve(listen); err != nil {
      ch &lt;- err
    }
  }(ch)

  // REST сервер
  go func() {
    // Создаем мультиплексер реализованный в grpc-gateway.
    // Как говорилось ранее grpc-gateway это обратный прокси сервер, который переводит REST в GRPC.
    mux := runtime.NewServeMux()

    // Данная функция была сгенерирована в файле microservice_grpc.pb.go.
    // Она подвязывает к gRPC серверу структуру которая реализовывает логику rpc ручек.
    // Тоже самое что и pb.RegisterMicroserviceServer, но для REST.
    err := pb.RegisterMicroserviceHandlerServer(context.Background(), mux, &amp;MicroserviceServer{})
    if err != nil {
      ch &lt;- err
    }

    // Создаем сервер на порту 8080 и передаем ему мультиплексер
    server := http.Server{
      Addr:    ":8080",
      Handler: mux,
    }

    // Запускаем REST сервер
    fmt.Println("REST server start :8080")
    if err = server.ListenAndServe(); err != nil {
      ch &lt;- err
    }
  }()

  // Слушаем каналы, если какой либо канал вернет ошибку, завершим работу сервера.
  for i := 0; i &lt; 2; i++ {
    if err := &lt;-ch; err != nil {
      panic(err)
    }
  }
}</code></pre>
  </div>
</div>

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>В этой статье мы разобрали базовые, основополагающие моменты в реализации <strong>gRPC</strong> сервера. Научились описывать <strong>Protobuf</strong> файлы, генерировать их в программный код стандартным способом и через плагин <strong>Buf</strong>, делать <strong>gRPC</strong> сервер совместимым с <strong>REST API</strong>, валидировать данные, разделять <strong>API</strong> на разные версии, реализовывать <strong>Swagger</strong> документацию и наконец запускать сервера <strong>gRPC</strong> и <strong>REST</strong>.</p>

<h3 id="ссылки-на-проект">Ссылки на проект</h3>

<ul>
  <li><a href="#golang-grpc" target="_blank" rel="nofollow">Исходный код</a></li>
</ul>]]></content><author><name></name></author><category term="backend" /><category term="golang" /><category term="gRPC" /><category term="rest" /><category term="swagger" /><category term="protobuf" /><category term="validate" /><summary type="html"><![CDATA[В этой статье затронем такие темы как gRPC, Rest API, Swagger, Protobuf, валидация данных и создадим веб сервер используя эти технологии.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Создание удобной обертки над Chi роутером с доступом к данным через context</title><link href="http://localhost:4000/blog/2024-01-31-sozdanie-udobnoj-obertki-nad-chi-routerom-s-dostupom-k-dannym-cherez-context-backend.html" rel="alternate" type="text/html" title="Создание удобной обертки над Chi роутером с доступом к данным через context" /><published>2024-01-31T07:00:00+06:00</published><updated>2024-01-31T07:00:00+06:00</updated><id>http://localhost:4000/blog/sozdanie-udobnoj-obertki-nad-chi-routerom-s-dostupom-k-dannym-cherez-context</id><content type="html" xml:base="http://localhost:4000/blog/2024-01-31-sozdanie-udobnoj-obertki-nad-chi-routerom-s-dostupom-k-dannym-cherez-context-backend.html"><![CDATA[<p>В этой статье создадим обертку над <b>Chi</b> роутером, которая позволит получать данные через контекст как во всех современных фреймворках на языке <b>Golang</b>.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#prepare">Подготовительные работы</a></li>
  <li><a href="#router">Создание роутера</a></li>
  <li><a href="#context">Создание контекста</a></li>
  <li><a href="#router-2">Создание роутера продолжение</a></li>
  <li><a href="#middleware">Использование сторонних middleware</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>В работе со стандартным роутером в <strong>Golang</strong>, обработчикам в качестве параметров передается запрос, ответ:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">GOLANG </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="golang ">// http
func Handler(w http.ResponseWrite, r *http.Request) {
  // code
}</code></pre>
  </div>
</div>

<p>В работе с различными фреймворками на языке <strong>Golang</strong>, при создании обработчиков используется паттерн, где в качестве параметра передается <strong>context</strong>, например:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">GOLANG </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="golang ">// Gin
func Handler(ctx *gin.Context) {
  // code
}

// Fiber
func Handler(ctx *fiber.Ctx) error {
  // code
}</code></pre>
  </div>
</div>

<p>Подход с контекстом является более гибким, он позволяет передавать помимо стандартного запроса, ответа еще и другие необходимые данные.</p>

<p>В этой статье мы создадим обертку, которая позволит создавать аналогичный с приведенными примерами обработчик.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">GOLANG </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="golang ">// Chix
func Handler(ctx *chix.Ctx) error {
  // code
}</code></pre>
  </div>
</div>

<h2 id="prepare"><span class="attention">Подготовительные</span> работы</h2>

<p>Первым делом необходимо инициализировать наш пакет (не забудьте изменить ссылку на репозиторий и название пакета на свои):</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go mod init github.com/eliofery/go-chix</code></pre>
  </div>
</div>

<p>Далее установим пакет роутера <strong>Chi</strong> на основе которого мы будем создавать свою обертку:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go get -u github.com/go-chi/chi/v5</code></pre>
  </div>
</div>

<p>После проделанных манипуляций создастся файл <strong>go.mod</strong>, примерно со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">GO.MOD </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="go.mod ">module github.com/eliofery/go-chix

go 1.21.5

require github.com/go-chi/chi/v5 v5.0.12 // indirect</code></pre>
  </div>
</div>

<h2 id="router"><span class="attention">Создание</span> роутера</h2>

<p>Начнем с создания обертки над <strong>Chi</strong> роутером.</p>

<p>В корне проекта создадим файл <strong>router.go</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">touch router.go</code></pre>
  </div>
</div>

<p>Внутри созданного файла создадим структуру нашего будущего роутера:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">package chix

import "github.com/go-chi/chi/v5"

// Router обертка над chi роутером
type Router struct {
  *chi.Mux
}</code></pre>
  </div>
</div>

<p>В структуре нашего роутера мы используем <strong>*chi.Mux</strong> которая является <strong>Chi</strong> роутером.</p>

<p>Далее создадим конструктор для нашей структуры <strong>Router</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// NewRouter создание роутера
func NewRouter() *Router {
  return &amp;Router{
    Mux: chi.NewRouter(),
  }
}</code></pre>
  </div>
</div>

<p>При создании нашего роутера создается новый роутер <strong>Chi</strong>, который мы будем использовать в описании своего обработчика.</p>

<p>В корне проекта создадим каталог <strong>_example</strong> и файл <strong>main.go</strong> внутри него:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">mkdir _example
touch _example/main.go</code></pre>
  </div>
</div>

<p>Со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">package main

import "github.com/eliofery/go-chix"

func main() {
  // Инициализация нашего роутера
  route := chix.NewRouter()
}</code></pre>
  </div>
</div>

<p>Теперь когда роутер, который является оберткой над роутером <strong>Chi</strong> создан, мы можем приступить к описанию методов.</p>

<h3 id="метод-get">Метод Get</h3>

<p>Первый метод который мы опишем, будет метод <strong>Get</strong>. Рассмотрим подробнее, что происходит:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// Get запрос на получение данных
// Обертка над методом Get у Chi роутера
// В качестве параметров мы так же используем path для определении маршрута,
// но далее мы переопределяем стандартный обработчик func(w http.ResponseWriter, r *http.Request) на handler Handler.
// Мы еще не описывали тип Handler, это будет сделано далее в статье.
func (rt *Router) Get(path string, handler Handler) {
  // Здесь мы вызываем стандартный метод Get у Chi роутера в обработчик которого в качестве логики
  // прописываем вызов приватного метода handler нашей структуры Router.
  // Далее мы разберем что такое handler Handler и rt.handler.
	rt.Mux.Get(path, func(w http.ResponseWriter, r *http.Request) {
		rt.handler(handler, w, r)
	})
}</code></pre>
  </div>
</div>

<h3 id="handler-и-rthandler">Handler и rt.handler</h3>

<p>Создадим тип Handler, прописав его в самом верху файла <strong>router.go</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// Handler обработчик
type Handler func(ctx *Ctx) error</code></pre>
  </div>
</div>

<p>Как вы могли заметить это тот самый обработчик, который похож на обработчики используемые в фреймворках.</p>

<p>Опишем приватный метод <strong>handler</strong> структуры <strong>Router</strong>, который принимает в качестве параметров, созданный выше тип <strong>Handler</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// handler запускает обработчик роутера
func (rt *Router) handler(handler Handler, w http.ResponseWriter, r *http.Request) {
  // При создании типа Handler мы прописали, что Handler является функцией, которая
  // принимает в качестве параметра контекст и возвращает ошибку: type Handler func(ctx *Ctx) error
  // Данной строкой мы создаем тот самый контекст, который принимает функция типа Handler
  // Мы еще не описывали внутреннюю логику создания контекста, это будет сделано далее.
  ctx := NewCtx(w, r)

  // Важно понимать что handler это тот самый обработчик нашего маршрута, который при использовании стандартного роутера
  // пакета http принимал в качестве параметров w http.ResponseWrite и r *http.Request.
  // Но сейчас наш handler принимает контекст.
  // Выше мы создали контекст ctx := NewCtx(w, r)
  // Теперь мы передаем, созданный контекст в наш обработчик handler(ctx).
  // Сразу не отходя от кассы мы проверяем была ли ошибка,
  // так как наш обработчик должен возвращать ошибку: func(ctx *Ctx) error
  // Если обработчик вернет ошибку мы формируем JSON ответ в который передаем значения
  // success (успешен ли запрос) и message (текст ошибки).
  // Мы так же пока не знакомы с содержимым метода JSON, далее в статье мы непременно его напишем.
  if err := handler(ctx); err != nil {
    err = ctx.JSON(Map{
      "success": false,
      "message": err.Error(),
    })

    // При отправки ответа так же может произойти ошибка, поэтому метод JSON так же возвращает ошибку.
    // Если ошибка произошла, то мы отображаем ее стандартным выводом пакета http.
    if err != nil {
      http.Error(ctx.ResponseWriter, "Не предвиденная ошибка", http.StatusInternalServerError)
    }
  }
}</code></pre>
  </div>
</div>

<h3 id="пример-использования-метода-get">Пример использования метода Get</h3>

<p>Прежде чем идти дальше и описывать код контекста <strong>(NewCtx)</strong>. Для лучшего понимания происходящего напишем обработчик для, созданного метода <strong>Get</strong>.</p>

<p>В файле <strong>_example/main.go</strong> к уже имеющемуся коду добавим:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">route.Get("/profile", func(ctx *chix.Ctx) error {
    // some code

    return nil
  })</code></pre>
  </div>
</div>

<p><strong>Теперь можно проследить логику:</strong></p>

<ol>
  <li>Создается маршрут <strong>profile</strong> для метода <strong>Get</strong>, с некоторым обработчиком <strong>func(ctx *chix.Ctx) error</strong>.</li>
  <li>При создании маршрута вызывается метод обертка <strong>Get</strong>. Который вызывает стандартный метод <strong>Get</strong> у роутера <strong>Chi</strong>. В данном методе прописан вызов приватного метода <strong>handler</strong> нашего <strong>Chix</strong> роутера.</li>
  <li>В приватный метод <strong>handler</strong> передается обработчик маршрута <strong>func(ctx *chix.Ctx) error</strong>.</li>
  <li>Приватный метод <strong>handler</strong> создает новый контекст.</li>
  <li>Вызывается переданный обработчик как <strong>callback</strong> функция, которая принимает в качестве параметра, созданный контекст <strong>handler(ctx)</strong>.</li>
  <li>При вызове обработчика исполняется его внутренний код <strong>func(ctx *chix.Ctx) error { return nil }</strong> и возвращается ошибка.</li>
  <li>При ошибке отправляется <strong>JSON</strong> ответ с сообщением об ошибке.</li>
  <li>Если при отправке <strong>JSON</strong> ответа произошла ошибка, то ошибка отобразится стандартным способом отображения ошибок пакета <strong>http</strong>.</li>
</ol>

<p><strong>На данный момент мы создали:</strong></p>

<ul>
  <li>type Handler func(ctx *Ctx) error</li>
  <li>type Router struct / func NewRouter() *Router</li>
  <li>func (rt *Router) handler(handler Handler, w http.ResponseWriter, r *http.Request)</li>
  <li>func (rt *Router) Get(path string, handler Handler)</li>
</ul>

<p><strong>Еще предстоит создать множество методов такие как:</strong></p>

<ul>
  <li>Post</li>
  <li>Put</li>
  <li>Patch</li>
  <li>Delete</li>
  <li>NotFound</li>
  <li>MethodNotAllowed</li>
  <li>Use</li>
  <li>Group</li>
  <li>With</li>
  <li>Route</li>
  <li>Mount</li>
  <li>ServeHTTP</li>
  <li>Listen</li>
</ul>

<p>Возможно это не все методы которые предоставляет <strong>Chi</strong> роутер, перечисленные методы это некая база часто используемых методов при работе с <strong>Chi</strong> роутером. Если обнаружится, что какой-то метод необходимый вам был пропущен, вы всегда сможете вокруг него создать обертку по аналогии с этой статьей.</p>

<p>Прежде чем продолжить создавать обертки для выше изложенных методов предлагаю разобраться с созданием контекста, который мы описывали ранее <strong>ctx := NewCtx(w, r)</strong>.</p>

<h2 id="context"><span class="attention">Создание</span> контекста</h2>

<p>В корне проекта создадим файл <strong>context.go</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">touch context.go</code></pre>
  </div>
</div>

<p>Со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">package chix

import "net/http"

// Map шаблон для передачи данных
// Данный тип уже был использован когда мы обрабатывали ошибку handler:
// Map{ "success": false, "message": err.Error() }
// Здесь мы его определяем.
type Map map[string]any

// Ctx контекст предоставляемый в обработчик
type Ctx struct {
  // Аналог w http.ResponseWrite
  http.ResponseWriter

  // Аналог r *http.Request
  *http.Request

  // Используется для middleware
  NextHandler http.Handler

  // Хранит статус ответа от сервера
  status int
}

// NewCtx создание контекста
// Здесь вместо обработчика сам контекст принимает запрос, ответ.
func NewCtx(w http.ResponseWriter, r *http.Request) *Ctx {
  return &amp;Ctx{
    ResponseWriter: w,
    Request:        r,

    // Здесь мы получаем следующий обработчик в цепочке middleware
    // Мы еще не знакомились с middleware и внутренней логикой кода NextHandler, это будет сделанно позже.
    NextHandler: NextHandler(r.Context()),

    status: http.StatusOK,
  }
}</code></pre>
  </div>
</div>

<p>При описании обработки ошибки <strong>handler(ctx)</strong> мы использовали <strong>ctx.JSON</strong>, опишем этот метод и многие другие необходимые для создания Rest API:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">// Status установка статуса ответа
func (ctx *Ctx) Status(status int) *Ctx {
  ctx.status = status
  return ctx
}

// Header установка заголовка
// Более компактная обертка для создания заголовков.
func (ctx *Ctx) Header(key, value string) {
  ctx.ResponseWriter.Header().Set(key, value)
}

// Decode декодирование тела запроса
// Декодирование json запроса.
func (ctx *Ctx) Decode(data any) error {
  if err := json.NewDecoder(ctx.Request.Body).Decode(data); err != nil {
    ctx.Status(http.StatusBadRequest)

    if errors.Is(err, io.EOF) {
      return errors.New("пустое тело запроса")
    }

    return errors.New("не корректный json")
  }

  return nil
}

// JSON формирование json ответа
// Отправка json ответа.
func (ctx *Ctx) JSON(data Map) error {
  ctx.Header("Content-Type", "application/json")
  ctx.WriteHeader(ctx.status)

  encoder := json.NewEncoder(ctx.ResponseWriter)
  encoder.SetIndent("", "  ")
  if err := encoder.Encode(data); err != nil {
    return err
  }

  return nil
}</code></pre>
  </div>
</div>

<p>Для лучшего понимая, что здесь произошло, вернемся к файлу <strong>_example/main.go</strong> и напишем следующий код:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">// Данные запрос, которые ожидаем получить от клиента
type Request struct {
  Name string
  Age  int
}

// Данные ответа, которые хотим отправить клиенту
type Response struct {
  Date time.Time
}

route.Get("/profile", func(ctx *chix.Ctx) error {
  // Запрос
  var req Request
  if err := ctx.Decode(&amp;req); err != nil {
    return ctx.Status(http.StatusBadRequest).JSON(chix.Map{
      "success": false,
      "message": err.Error(),
    })
  }

  // Некая бизнес логика
  var res Response
  res.Date = time.Now()

  // Ответ
  return ctx.JSON(chix.Map{
    "success": true,
    "message": "Время ответа",
    "data":    res,
  })
})</code></pre>
  </div>
</div>

<p>Как видим наш обработчик роутера становится похожим на привычные обработчики из любимых фреймворков.</p>

<h2 id="router-2"><span class="attention">Создание</span> роутера продолжение</h2>

<p>Настала пора вернуться к реализации описанных ранее недостающих методов для нашего роутера:</p>

<ul>
  <li>Post</li>
  <li>Put</li>
  <li>Patch</li>
  <li>Delete</li>
  <li>NotFound</li>
  <li>MethodNotAllowed</li>
  <li>Use</li>
  <li>Group</li>
  <li>With</li>
  <li>Route</li>
  <li>Mount</li>
  <li>ServeHTTP</li>
  <li>Listen</li>
</ul>

<p>Методы <strong>Post</strong>, <strong>Put</strong>, <strong>Patch</strong>, <strong>Delete</strong>, <strong>NotFound</strong>, <strong>MethodNotAllowed</strong> мало чем отличаются от созданного ранее метода <strong>Get</strong>. Поэтому я не буду вдаваться в подробности как они работают, просто опишу их логику:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">// Post запрос на добавление данных
func (rt *Router) Post(path string, handler Handler) {
  rt.Mux.Post(path, func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}

// Put запрос на обновление всех данных
func (rt *Router) Put(path string, handler Handler) {
  rt.Mux.Put(path, func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}

// Patch запрос на обновление конкретных данных
func (rt *Router) Patch(path string, handler Handler) {
  rt.Mux.Patch(path, func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}

// Delete запрос на удаление данных
func (rt *Router) Delete(path string, handler Handler) {
  rt.Mux.Delete(path, func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}

// NotFound обрабатывает 404 статус
func (rt *Router) NotFound(handler Handler) {
  rt.Mux.NotFound(func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}

// MethodNotAllowed обрабатывает 405 статус
func (rt *Router) MethodNotAllowed(handler Handler) {
  rt.Mux.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) {
    rt.handler(handler, w, r)
  })
}</code></pre>
  </div>
</div>

<p>С остальными методами будет поинтересней.</p>

<h3 id="метод-use">Метод Use</h3>

<p>Метод <strong>Use</strong> добавляет промежуточное программное обеспечение <strong>(middleware)</strong>. Он пересекается с конструкцией <strong>NextHandler http.Handler</strong>, с которой мы столкнулись при создании структуры контекста:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">type Ctx struct {
  ...
  NextHandler http.Handler
  ...
}</code></pre>
  </div>
</div>

<p>Ниже приведу код метода <strong>Use</strong>, а затем вернемся к <strong>NextHandler</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">// Use добавляет промежуточное программное обеспечение
func (rt *Router) Use(middlewares ...Handler) {
  // Перебираем все полученные middleware
  for _, middleware := range middlewares {
    // Обязательно создаем отдельную переменную, хранящую текущий middleware
    // Это обусловлено особенностью самого языка golang, так как если не сохранить
    // текущую итерацию, то получать в обработчике будем всегда самую последнюю.
    currentMiddleware := middleware

    // Тут вызываем метод Use Chi роутера
    rt.Mux.Use(func(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Добавляем в текущий контекст следующий обработчик в цепочке middleware
        ctx := r.Context()
        ctx = WithNextHandler(ctx, next)

        // Вызываем метод handler, разобранный ранее в который передаем на этот раз
        // вместо обработчика роута, обработчик middleware.
        // Далее передаем ответ (w) и запрос (r), обратите внимание что r передается по особенному,
        // здесь мы переопределяем контекст в запросе роутера.
        rt.handler(currentMiddleware, w, r.WithContext(ctx))
      })
    })
  }
}</code></pre>
  </div>
</div>

<h3 id="next-handler">Next Handler</h3>

<p>Теперь давайте разберемся что же такое <strong>WithNextHandler</strong>, для этого в корне проекта создадим файл <strong>next_handler.go</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">touch next_handler.go</code></pre>
  </div>
</div>

<p>Со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">NEXT_HANDLER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="next_handler.go">package chix

import (
  "context"
  "net/http"
)

// Тип key ключ контекста
type key string

// Значение ключа
const nextKey key = "next"

// WithNextHandler добавление следующего обработчика в цепочке middleware в контекст
func WithNextHandler(ctx context.Context, next http.Handler) context.Context {
  return context.WithValue(ctx, nextKey, next)
}

// NextHandler получение следующего обработчика в цепочке middleware из контекста
func NextHandler(ctx context.Context) http.Handler {
  val := ctx.Value(nextKey)

  next, ok := val.(http.Handler)
  if !ok {
    return nil
  }

  return next
}</code></pre>
  </div>
</div>

<p>При регистрации <strong>middleware</strong> через метод <strong>Use</strong> мы добавляем в контекст через функцию <strong>WithNextHandler</strong> следующий обработчик и возвращаем получившийся контекст с добавленными данными.</p>

<p>При создании нового контекста <strong>NewCtx(w, r)</strong> мы передаем текущий контекст в функцию <strong>NextHandler</strong> для того, чтобы получить следующий в цепочке <strong>middleware</strong> обработчик и сохраняем его в свойстве <strong>NextHandler</strong> у структуры <strong>Ctx</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">func NewCtx(w http.ResponseWriter, r *http.Request) *Ctx {
  return &amp;Ctx{
    ...
    // Cохраняем следующий в цепочке **middleware** обработчик в свойстве **NextHandler**
    NextHandler: NextHandler(r.Context()),
    ...
  }
}</code></pre>
  </div>
</div>

<p>Чтобы полученная информация улеглась в голове, напишем тестовый <strong>middleware</strong>, чтобы на практике увидеть, то что мы описали.</p>

<p>В каталоге <strong>_example</strong> создадим файл <strong>middleware</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">touch _example/middleware.go</code></pre>
  </div>
</div>

<p>Со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MIDDLEWARE.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="middleware.go">package main

import (
  "github.com/eliofery/go-chix"
)

// Example пример реализации middleware
// Мне нравится создавать middleware именно таким способом, а не напрямую например:
// func Example(ctx *chix.Ctx) error {}
// Так как в middleware при желании можно передать необходимые параметры например:
// Example(foo string, bar int) chix.Handler {}
// Затем внутри middleware ими воспользоваться.
func Example() chix.Handler {
  return func(ctx *chix.Ctx) error {
    // Некая логика
    // Если произошла ошибка, то возвращаем ошибку
    // и цепочка middleware будет прервана.
    if false {
      return errors.New("некая ошибка")
    }

    // При успешной логике вызываем следующий обработчик
    // в цепочке middleware
    return ctx.Next()
  }
}</code></pre>
  </div>
</div>

<p>Вы могли заметить, что метод <strong>ctx.Next()</strong> нам неизвестен, так как мы его еще не описывали. Самое время исправить этот момент, откроем файл <strong>context.go</strong> и добавим метод <strong>Next</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">CONTEXT.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="context.go">// Next обработка следующего обработчика
func (ctx *Ctx) Next() error {
  // ServeHTTP стандартный метод интерфейса http.Handler
  // Произойдет вызов следующего обработчика
  ctx.NextHandler.ServeHTTP(ctx.ResponseWriter, ctx.Request)

  return nil
}</code></pre>
  </div>
</div>

<p>Метод <strong>Next</strong> позволяет вызвать сохраненный <strong>ctx.NextHandler</strong> благодаря чему происходит обработка следующего <strong>middleware</strong> в цепочке.</p>

<p>С методом <strong>Use</strong> который регистрирует промежуточные программные обеспечения <strong>(middleware)</strong> покончено. Было не просто понадобится какое-то время, чтобы разобраться со всем, что здесь произошло, а я перехожу к реализации следующего метода.</p>

<h3 id="метод-with">Метод With</h3>

<p>Метод With используется для добавления middleware к группе маршрутов, что облегчает добавление одних и тех же middleware к нескольким маршрутам.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// With добавляет встроенное промежуточное программное обеспечение для обработчика конечной точки
func (rt *Router) With(middlewares ...Handler) *Router {
  // Так как стандартный метод With роутера Chi принимает множество обработчиков func(http.Handler) http.Handler
  // Необходимо смоделировать этот тип данных.
  var handlers []func(http.Handler) http.Handler

  // Далее код аналогичен тому, что мы прописывали в методе Use за исключением того,
  // что мы сохраняем обработчик в массиве, который создали выше
  for _, middleware := range middlewares {
    currentMiddleware := middleware

    handler := func(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        ctx = WithNextHandler(ctx, next)

        rt.handler(currentMiddleware, w, r.WithContext(ctx))
      })
    }

    handlers = append(handlers, handler)
  }

  // Создаем новый роутер используя переданные middlewares
  return &amp;Router{
    Mux: rt.Mux.With(handlers...).(*chi.Mux),
  }
}</code></pre>
  </div>
</div>

<p>Опишем пример использования метода <strong>With</strong>, для этого откроем файл <strong>_example/main.go</strong> и добавим:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">route.With(Example()).Route("/group", func(r *chix.Router) {
  r.Get("/route1", func(ctx *chix.Ctx) error { return nil })
  r.Get("/route2", func(ctx *chix.Ctx) error { return nil })
})</code></pre>
  </div>
</div>

<p>Мы еще не определили метод <strong>Route</strong> давайте этим и займемся.</p>

<h3 id="метод-route">Метод Route</h3>

<p>Метод <strong>Route</strong> создает вложенность роутеров.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">// Route создает вложенность роутеров
func (rt *Router) Route(pattern string, fn func(r *Router)) *Router {
  // Создаем дочерний роутер
  subRouter := &amp;Router{
    Mux: chi.NewRouter(),
  }

  // Передаем его внутрь атрибута fn
  fn(subRouter)

  // Mount добавляет вложенность роутеров друг в друга.
  // В данном случае мы вкладываем внутрь родительского роута rt дочерний роут subRouter.
  // Мы еще не описывали метод Mount, займемся этим позже.
  rt.Mount(pattern, subRouter)

  return subRouter
}</code></pre>
  </div>
</div>

<p>После добавления метода <strong>Route</strong> текстовый редактор должен перестать ругаться на пример описанный ваше в файле <strong>main.go</strong>.</p>

<h3 id="метод-mount">Метод Mount</h3>

<p>Метод Mount добавляет вложенность роутеров друг в друга.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MAIN.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="main.go">// Mount добавляет вложенность роутеров
func (rt *Router) Mount(pattern string, router *Router) {
  // Здесь мы так же создаем обертку для того, чтобы использовать нашу структуру роутера
  // вместо Chi роутера.
  rt.Mux.Mount(pattern, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // Запускаем наш роут
    router.Mux.ServeHTTP(w, r)
  }))
}</code></pre>
  </div>
</div>

<h3 id="метод-group">Метод Group</h3>

<p>Метод <strong>Group</strong> позволяет группировать роутеры.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// Group группирует роутеры
func (rt *Router) Group(fn func(r *Router)) *Router {
  // Создаем роут с привязкой middlewares
  // Возможно можно было ограничиться лишь переменной rt, например: fn(rt),
  // но я не уверен, что это сработает, так как сам Chi использует подход
  // с созданием роута через метод With.
	im := rt.With()

	if fn != nil {
		fn(im)
	}

	return im
}</code></pre>
  </div>
</div>

<p>Львиная часть методов позади осталось всего нечего.</p>

<h3 id="метод-servehttp">Метод ServeHTTP</h3>

<p>Метод ServeHTTP возвращает весь пул роутеров.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// ServeHTTP возвращает весь пул роутеров
func (rt *Router) ServeHTTP() http.HandlerFunc {
  // Здесь ни чего особенного просто возвращаем стандартный http.HandlerFunc
  return rt.Mux.ServeHTTP
}</code></pre>
  </div>
</div>

<h3 id="метод-listen">Метод Listen</h3>

<p>Метод Listen запускает сервер. Является локомотивом нашего роутера без которого ни чего не заработает.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">// Listen запускает сервер
// Реализация: https://github.com/go-chi/chi/blob/master/_examples/graceful/main.go
func (rt *Router) Listen(addr string) error {
  // Создаем сервер
  server := &amp;http.Server{
    Addr:    addr,
    Handler: rt.ServeHTTP(),
  }

  // Подписываемся на сигналы операционной системы, в данном случе на сигнал os.Interrupt,
  // который вызывается ОС при нажатии на клавиши Ctrl + C.
  ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
  defer cancel()

  // Создаем канал для ошибок
  ch := make(chan error, 1)

  // Запускаем сервер в горутине
  go func() {
    if err := server.ListenAndServe(); err != nil {
      // Если возникла ошибка при запуске сервера отправляем ошибку в канал
      if !errors.Is(err, http.ErrServerClosed) {
        fmt.Printf("Не удалось запустить сервер: %s", err.Error())
        ch &lt;- ctx.Err()
      }
    }
    close(ch)
  }()

  // Слушаем каналы
  select {
  // При ошибке запуска сервера
  case err := &lt;-ch:
    panic(err)
  // При ошибки завершения работы сервера
  case &lt;-ctx.Done():
    // Создаем таймер в течении 10 сек. сервер должен завершить свою работу при
    // Нажатии на Ctrl + C
    timeoutCtx, done := context.WithTimeout(context.Background(), time.Second*10)
    defer done()

    // Ловим завершение работы с сервером
    go func() {
      &lt;-timeoutCtx.Done()
      if errors.Is(timeoutCtx.Err(), context.DeadlineExceeded) {
        fmt.Printf("Время корректного завершения работы истекло. Принудительный выход: %s", timeoutCtx.Err().Error())
      }
    }()

    // Завершаем работу с сервером
    if err := server.Shutdown(timeoutCtx); err != nil {
      fmt.Printf("Не удалось остановить сервер: %s", err.Error())
    }
  }

  return nil
}</code></pre>
  </div>
</div>

<h2 id="middleware"><span class="attention">Использование</span> сторонних middleware</h2>

<p>Мы разобрали как в рамках нашего роутера создается <strong>middleware</strong>. Но бывают моменты когда необходимо использовать готовые <strong>middleware</strong> под роутер <strong>Chi</strong> и тут возникает нюанс. Который разберем в данном разделе на примере <strong>middleware Cors</strong>.</p>

<p>Скачаем пакет <strong>github.com/go-chi/cors</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">go get github.com/go-chi/cors</code></pre>
  </div>
</div>

<p>В каталоге <strong>_example</strong> создадим файл <strong>cors.go</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ROUTER.GO</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="router.go">package main

import (
	"github.com/eliofery/go-chix"
	"github.com/go-chi/cors"
)

const defaultCorsMaxAge = 3600 // 1 час

// Cors настройки межсайтового взаимодействия
// Пример: https://github.com/go-chi/cors?tab=readme-ov-file#usage
func Cors() chix.Handler {
  // Используем обработчик нашего роутера
  return func(ctx *chix.Ctx) error {
    // Создаем Cors обработчик сохраняя его в переменной
    corsHandler := cors.Handler(cors.Options{
      AllowedOrigins:   []string{"http://localhost:3000"},
      AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
      AllowedHeaders:   []string{"Origin", "Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
      ExposedHeaders:   []string{"Link", "Content-Length", "Access-Control-Allow-Origin"},
      AllowCredentials: true,
      MaxAge:           defaultCorsMaxAge,
    })

    // Передаем в cors обработчик следующий обработчик и выполняем его.
    // Далее если внутри логики cors возникнет ошибка corsHandler сам прервет цепочку middleware.
    // Нам нет надобности вызывать ctx.Next()
    corsHandler(ctx.NextHandler).ServeHTTP(ctx.ResponseWriter, ctx.Request)

    return nil
  }
}</code></pre>
  </div>
</div>

<p>Вот таким нехитрым образом мы подружили стандартный <strong>Chi middleware</strong> с нашим роутером.</p>

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>В этой статье мы создали свою обертку над <strong>Chi</strong> роутером благодаря которой наш опыт использования этого маршрутизатора будет похож на использование привычных фреймворков на подобии <strong>gin</strong> и <strong>fiber</strong>.</p>

<h3 id="ссылки-на-проект">Ссылки на проект</h3>

<ul>
  <li><a href="https://github.com/eliofery/chix-router" target="_blank" rel="nofollow">Исходный код</a></li>
  <li><a href="https://github.com/eliofery/go-chix" target="_blank" rel="nofollow">Фреймворк на базе Chix роутера</a></li>
</ul>]]></content><author><name></name></author><category term="backend" /><category term="golang" /><category term="chi" /><category term="context" /><summary type="html"><![CDATA[В этой статье создадим обертку над Chi роутером, которая позволит получать данные через контекст как во всех современных фреймворках на языке Golang.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Автоматическая компиляция Golang проекта при изменении файлов</title><link href="http://localhost:4000/blog/2024-01-21-avtomaticheskaya-kompilyaciya-golang-proekta-pri-izmenenii-fajlov-backend.html" rel="alternate" type="text/html" title="Автоматическая компиляция Golang проекта при изменении файлов" /><published>2024-01-21T07:00:00+06:00</published><updated>2024-01-21T07:00:00+06:00</updated><id>http://localhost:4000/blog/avtomaticheskaya-kompilyaciya-golang-proekta-pri-izmenenii-fajlov</id><content type="html" xml:base="http://localhost:4000/blog/2024-01-21-avtomaticheskaya-kompilyaciya-golang-proekta-pri-izmenenii-fajlov-backend.html"><![CDATA[<p>В этой статье настроим слежение за изменением файлов. При котором будет автоматически перекомпилироваться <b>Golang</b> проект.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#download">Установка modd</a></li>
  <li><a href="#setting">Настройка modd</a></li>
  <li><a href="#run">Запуск modd</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p><strong>Golang</strong> является компилируемым языком программирования. Вследствие чего каждое изменение кода необходимо каждый раз заново компилировать, чтобы увидеть изменения в программе.</p>

<p>Данная манипуляция может утомить если приходится раз за разом перекомпилировать проект. В данной статье мы рассмотрим как можно упростить этот момент в разработке.</p>

<h2 id="download"><span class="attention">Установка</span> modd</h2>

<p>Для решения нашей задачи необходимо установить <a href="https://github.com/cortesi/modd" target="_blank" rel="nofollow">пакет modd</a>. Для этого в терминале введем команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go install github.com/cortesi/modd/cmd/modd@latest</code></pre>
  </div>
</div>

<p>Данный пакет будет скачен в каталог <strong>~/golang/packages/bin</strong>, который мы настроили в <a href="/blog/2024-01-20-ustanovka-i-ispolzovanie-neskolkih-versij-golang-backend.html" target="_blank">прошлой статье</a>.</p>

<h2 id="setting"><span class="attention">Настройка</span> modd</h2>

<p>В корне проекта создадим файл <strong>modd.conf</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">MODD.CONF </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="modd.conf "># Проверка всех тестов при первой запуске
**/*.go {
  prep: go test @dirmods
}

# Автоматическая компиляция проекта при изменении файлов
# Исключает все тестовые файлы *_test.go
**/*.go !**/*_test.go {
  prep: go build -o ./bin ./cmd/main.go
  daemon +sigterm: ./bin
}</code></pre>
  </div>
</div>

<p>При первом запуске <strong>modd</strong> пакета будут проверены все имеющиеся тесты. Далее уже идет непосредственно настройки слежения за изменением файлов.</p>

<p>В данном случае мы следим за изменением всех файлов с расширением <strong>.go</strong> кроме тестовых. При изменении содержимого какого либо <strong>go</strong> файла будет происходить перекомпиляция всего проекта.</p>

<p>Строкой <strong>prep: go build -o ./bin ./cmd/main.go</strong> мы говорим, чтобы компилировался файл <strong>./cmd/main.go</strong>, а результат его компиляции был помещен в каталоге <strong>./bin</strong>.</p>

<p>Строкой <strong>daemon +sigterm: ./bin</strong> мы автоматически запускаем скомпилированный файл, в результате чего отобразится актуальный результат.</p>

<h2 id="run"><span class="attention">Запуск</span> modd</h2>

<p>Чтобы запустить режим слежения за изменением файлов, достаточно ввести в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">modd</code></pre>
  </div>
</div>

<p>Иногда могут возникнуть случаи при которых вы будете ожидать перекомпиляцию, но она не произойдет. Например, при какой-либо серьезной ошибки в программе. Чтобы решить этот нюанс, необходимо отменить слежение за изменение файлов, нажав в терминале горячие клавиши <kbd>Ctrl + C</kbd> и по новой выполнить команду <strong>modd</strong>.</p>

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>В этой статье мы научились пользоваться довольно полезным инструментом <strong>modd</strong>, который позволяет автоматизировать рутину компиляции программы при разработке.</p>]]></content><author><name></name></author><category term="backend" /><category term="golang" /><category term="modd" /><summary type="html"><![CDATA[В этой статье настроим слежение за изменением файлов. При котором будет автоматически перекомпилироваться Golang проект.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Установка и использование нескольких версий Golang</title><link href="http://localhost:4000/blog/2024-01-20-ustanovka-i-ispolzovanie-neskolkih-versij-golang-backend.html" rel="alternate" type="text/html" title="Установка и использование нескольких версий Golang" /><published>2024-01-20T11:44:00+06:00</published><updated>2024-01-20T11:44:00+06:00</updated><id>http://localhost:4000/blog/ustanovka-i-ispolzovanie-neskolkih-versij-golang</id><content type="html" xml:base="http://localhost:4000/blog/2024-01-20-ustanovka-i-ispolzovanie-neskolkih-versij-golang-backend.html"><![CDATA[<p>В этой статье установим различные версии языка программирования <b>Golang</b> для дальнейшего их использования.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#download">Скачивание Golang</a></li>
  <li><a href="#path">Переменные среды</a></li>
  <li><a href="#end">Подведем итоги</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>На официальном сайте <strong>Golang</strong> предоставлена наглядная пошаговая <a href="https://go.dev/doc/install" target="_blank" rel="nofollow">инструкция по установке</a> этого замечательного языка программирования. Здесь же поделюсь своим немного видоизмененным вариантом.</p>

<h2 id="download"><span class="attention">Скачивание</span> Golang</h2>

<p>Перед скачиванием нужной версии, создадим каталог в котором будут храниться различные версии <strong>Golang</strong>. Путь до каталога не принципиален, можно выбрать абсолютно любой какой вам удобен и привычен. Я обычно храню все версии <strong>Golang</strong> и его пакеты в каталоге <strong>golang</strong> который размещаю в <strong>Домашней папке (/home/&lt;user&gt;/golang)</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">mkdir ~/golang
cd ~/golang</code></pre>
  </div>
</div>

<p>Далее переходим на страницу <a href="https://go.dev/dl/" target="_blank" rel="nofollow">официального сайта</a>, с перечнем доступных версий <strong>Golang</strong> и скачиваем нужный нам архив.</p>

<p>Распаковываем скаченный архив в созданный каталог, у меня это <strong>~/golang</strong> и переименовываем его так, чтобы было понятно какая это версия, например <strong>go-1.21.4</strong>. И того должно получиться <strong>~/golang/go1.21.4</strong>.</p>

<p>Предположим, что вышла новая версия <strong>Golang 1.21.5</strong>. Так же скачиваем архив, с данной версией на официальном сайте и распаковываем ее в созданный каталог <strong>~/golang/go1.21.5</strong>. И того должна получиться следующая структура:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">~/golang
├── go-1.21.4
├── go-1.21.5</code></pre>
  </div>
</div>

<p>Аналогичным образом в дальнейшем добавляем другие версии.</p>

<h2 id="path"><span class="attention">Переменные</span> среды</h2>

<h3 id="goroot">GOROOT</h3>

<p><strong>GOROOT</strong> - хранит путь до используемой версии <strong>Golang</strong>.</p>

<p>Сейчас если вести в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go version</code></pre>
  </div>
</div>

<p>Мы получим ошибку <strong>go: команда не найдена</strong>. Так как переменные среды не были настроены и терминал не знает где ему искать исполняемый файл <strong>go</strong>. Чтобы это исправить откроем в привычном вам редакторе файл <strong>~/.profile</strong> и добавим в него следующую конструкцию:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.PROFILE </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".profile "># golang
export GOROOT=~/golang/go1.21.5
export PATH=$PATH:$GOROOT/bin</code></pre>
  </div>
</div>

<p>Далее мы расширяем переменную сред <strong>PATH</strong> добавив к ее значениям <strong>$GOROOT/bin</strong>, ссылающуюся на исполняемый файл <strong>Golang</strong>.</p>

<p>Перезапустим терминал либо введем команду, чтобы изменения вступили в силу:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">source ~/.profile</code></pre>
  </div>
</div>

<p>Теперь если ввести в терминале команду:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go version</code></pre>
  </div>
</div>

<p>Вместо ошибки увидим текущую версию <strong>go version go1.21.5 linux/amd64</strong>.</p>

<h3 id="gopath">GOPATH</h3>

<p><strong>GOPATH</strong> - хранит путь до сторонних пакетов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">go get &lt;package&gt;
go install &lt;package&gt;</code></pre>
  </div>
</div>

<p>Необходимо явно указать каталог куда сторонние пакеты будут скачены. Для этого создадим каталог <strong>~/golang/packages</strong> рядом с версиями <strong>Golang</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">mkdir ~/golang/packages</code></pre>
  </div>
</div>

<p>Остается добавить, созданный каталог в переменные среды по аналогии как это было сделано с <strong>GOROOT</strong> и того должно получиться:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.PROFILE </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".profile "># golang
export GOROOT=~/golang/go1.21.5
export GOPATH=~/golang/packages
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre>
  </div>
</div>

<p>Перезапустим терминал либо введем команду, чтобы изменения вступили в силу:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH </div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash ">source ~/.profile</code></pre>
  </div>
</div>

<h2 id="end"><span class="attention">Подведем</span> итоги</h2>

<p>В этой статье мы научились устанавливать и использовать различные версии <strong>Golang</strong>. При использовании <strong>IDE GoLand</strong> можно с легкостью переключаться между версиями, а так же добавлять новые, скачивая их через раздел настроек <strong>GoLand</strong>.</p>]]></content><author><name></name></author><category term="backend" /><category term="golang" /><category term="пакеты" /><summary type="html"><![CDATA[В этой статье установим различные версии языка программирования Golang для дальнейшего их использования.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Создаем самописный framework на нативном JavaScript используя Webpack</title><link href="http://localhost:4000/blog/2023-09-18-sozdaem-svoj-framework-na-nativnom-javascript-ispolzuya-webpack-frontend.html" rel="alternate" type="text/html" title="Создаем самописный framework на нативном JavaScript используя Webpack" /><published>2023-09-18T14:23:00+06:00</published><updated>2023-09-18T14:23:00+06:00</updated><id>http://localhost:4000/blog/sozdaem-svoj-framework-na-nativnom-javascript-ispolzuya-webpack</id><content type="html" xml:base="http://localhost:4000/blog/2023-09-18-sozdaem-svoj-framework-na-nativnom-javascript-ispolzuya-webpack-frontend.html"><![CDATA[<p>В этой статье речь пойдет о написании своего велосипеда в виде <b>JavaScript framework</b>. Затронем такие технологии как <b>Webpack</b>, <b>Linter</b>, <b>Redux</b>.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#base">Базовая инициализация</a></li>
  <li><a href="#babel">Установка Babel</a></li>
  <li><a href="#linter">Установка линтеров</a></li>
  <li><a href="#linter-settings">Настройка линтеров</a></li>
  <li><a href="#webpack">Установка Webpack</a></li>
  <li><a href="#webpack-settings">Настройка Webpack</a></li>
  <li><a href="#structure">Структура проекта</a></li>
  <li><a href="#base-settings">Базовая настройка проекта</a></li>
  <li><a href="#core">Ядро фремворка</a></li>
  <li><a href="#router">Класс Router</a></li>
  <li><a href="#app">Класс App</a></li>
  <li><a href="#base-component">Класс BaseComponent</a></li>
  <li><a href="#base-page">Класс BasePage</a></li>
  <li><a href="#main-layout">Класс MainLayout</a></li>
  <li><a href="#pages">Страницы HomePage, AboutPage, ErrorPage</a></li>
  <li><a href="#logo-component">Компонент LogoComponent</a></li>
  <li><a href="#link-component">Компонент Link</a></li>
  <li><a href="#reponse">Компонент Response</a></li>
  <li><a href="#store">Компонент Store</a></li>
  <li><a href="#end">Итоги создания фреймворка</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Основная идея заключается в создании простого, легковесного <strong>фреймворка</strong> используя возможности нативного <strong>JavaScript</strong>. В дальнейшем на основе него будет создано одностраничное приложение (<strong>SPA</strong>).</p>

<p>Каждый шаг создания <strong>JavaScript framework</strong> можно будет отследить <a href="https://github.com/eliofery/javascript-framework-webpack/commits/main" target="_blank" rel="nofollow">в репозитории</a>.</p>

<h2 id="base"><span class="attention">Базовая </span> инициализация</h2>

<p>Создадим базовые файлы для проекта, инициализируем <strong>git</strong> и <strong>npm</strong>. О том как <a href="/blog/2023-08-21-linux-dlya-nachinayushhih-chast-3-soft-dlya-povsednevnyh-zadach-linux.html#git" target="_blank">установить</a> и <a href="/blog/2023-08-23-nastrojka-git-program.html" target="_blank">настроить</a> <strong>git</strong> говорилось в соответствующих статьях, так же и про <a href="/blog/2023-08-21-linux-dlya-nachinayushhih-chast-3-soft-dlya-povsednevnyh-zadach-linux.html#node" target="_blank">установку npm</a>.</p>

<h3 id="cоздание-readmemd">Cоздание README.md</h3>

<p>В корень проекта добавим файл <strong>README.md</strong> для вводной информации о сборке.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">README.MD</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="README.md"># JavaScript framework

Свой велосипед на нативном **javascript** для создания **spa** приложений.</code></pre>
  </div>
</div>

<h3 id="инициализация-git">Инициализация Git</h3>

<p><strong>Git</strong> нам понадобится в качестве системы учета контроля версий. В дальнейшем мы будем делать <strong>commit</strong> предварительно пропуская сохраняемые файлы через <strong>linter</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">git init</code></pre>
  </div>
</div>

<h3 id="создание-gitignore">Создание .gitignore</h3>

<p>В корне проекта создадим файл <strong>.gitignore</strong>, в нем мы будем прописывать пути к каталогам и файлам которые не следует добавлять в репозиторий.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.GITIGNORE</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".gitignore">.idea
.vscode
node_modules
.eslintcache</code></pre>
  </div>
</div>

<h3 id="инициализация-npm">Инициализация Npm</h3>

<p>Удостоверьтесь что у вас установлен <a href="/blog/2023-08-21-linux-dlya-nachinayushhih-chast-3-soft-dlya-povsednevnyh-zadach-linux.html#node" target="_blank">Node.js</a>. Инициализируем пакетный менеджер зависимостей <strong>npm</strong>, с его помощью мы будем устанавливать необходимые зависимости для нашего проекта.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm init -y</code></pre>
  </div>
</div>

<p>В корне проекта создастся файл <strong>package.json</strong>, примерное содержимое файла:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JSON</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="json">{
  "name": "javascript-framework-webpack",
  "version": "0.0.1",
  "description": "JavaScript framework для создания spa приложений.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": ["webpack"],
  "author": "",
  "license": "ISC"
}</code></pre>
  </div>
</div>

<h2 id="babel"><span class="attention">Установка</span> и настройка Babel</h2>

<p><strong>Babel</strong> - это инструмент для компиляции и транспиляции <strong>JavaScript</strong> кода. Он применяется для преобразования современного <strong>JavaScript</strong>, написанного с использованием новых синтаксических возможностей ES6+, в старый совместимый код, который может работать в различных браузерах и средах выполнения.</p>

<p>Более подробно об установке <strong>Babel</strong> говорилось статье про <a href="/blog/2023-08-29-gulp-sborka-dlya-verstki-s-ispolzovaniem-pug-shablonizatora-frontend.html#gulp" target="_blank">создание <strong>Gulp</strong> сборки</a>, здесь же коснемся самого основного.</p>

<p>Установим необходимые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D @babel/core @babel/register @babel/preset-env core-js</code></pre>
  </div>
</div>

<h3 id="настройка-babel">Настройка Babel</h3>

<p>В корне проекта создадим файл <strong>.babelrc</strong> со следующим содержимым.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.BABELRC</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".babelrc">{
  "presets": [
    [
      "@babel/preset-env",
      {
        "debug": false,
        "useBuiltIns": "usage",
        "corejs": "3"
      }
    ]
  ]
}</code></pre>
  </div>
</div>

<h3 id="настройка-browserslist">Настройка Browserslist</h3>

<p><strong>Browserslist</strong> - это инструмент, который используется для определения набора браузеров, поддерживаемых веб-проектом.</p>

<p>В дальнейшем его настройки пригодятся для компиляции <strong>JavaScript</strong> кода, а так же использования <strong>Autoprefixer</strong> для <strong>CSS</strong> стилей. Отредактируем файл <strong>package.json</strong>, добавив следующую конструкцию:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JSON</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="json">"browserslist": [
  "last 2 version",
  "not dead"
],</code></pre>
  </div>
</div>

<p>Здесь мы поддерживаем последние 2 версии браузеров и все браузеры которые продолжают развиваться.</p>

<h2 id="linter"><span class="attention">Установка</span> линтеров</h2>

<p>Линтеры позволяют поддерживать весь код проекта в единообразном стиле, придерживаясь определенных правил написания кода. Линтер не позволит пользователю создать <strong>commit</strong> до тех пор, пока код не будет отредактирован согласно правилам.</p>

<p>Более подробно <strong>линтеры</strong> были рассмотрены в статье <a href="/blog/2023-08-29-gulp-sborka-dlya-verstki-s-ispolzovaniem-pug-shablonizatora-frontend.html#linter" target="_blank">создание <strong>Gulp</strong> сборки</a>, здесь же коснемся самого основного.</p>

<h3 id="javascript">JavaScript</h3>

<p>Установим необходимые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D eslint @babel/eslint-parser eslint-plugin-import eslint-config-airbnb-base eslint-config-prettier eslint-import-resolver-webpack</code></pre>
  </div>
</div>

<p><strong>eslint-import-resolver-webpack</strong> - это плагин который используется для определения местоположения модулей при разрешении импортов в проектах.</p>

<p>Описание остальных плагинов смотрите в статье <a href="/blog/2023-08-29-gulp-sborka-dlya-verstki-s-ispolzovaniem-pug-shablonizatora-frontend.html#linter" target="_blank">создание <strong>Gulp</strong> сборки</a>.</p>

<h3 id="css-и-scss">CSS и SCSS</h3>

<p>Установим необходимые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D stylelint stylelint-config-rational-order stylelint-config-recommended-scss stylelint-config-standard stylelint-order stylelint-scss</code></pre>
  </div>
</div>

<h3 id="editorconfig-и-prettier">Editorconfig и Prettier</h3>

<p>Установим необходимые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D editorconfig-checker prettier</code></pre>
  </div>
</div>

<h3 id="lint-staged">Lint staged</h3>

<p>Установим необходимые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npx mrm lint-staged</code></pre>
  </div>
</div>

<h2 id="linter-settings"><span class="attention">Настройка </span> линтеров</h2>

<p>Более подробно настройки <strong>линтеров</strong> были описаны в статье <a href="/blog/2023-08-29-gulp-sborka-dlya-verstki-s-ispolzovaniem-pug-shablonizatora-frontend.html#setting-linter" target="_blank">создание <strong>Gulp</strong> сборки</a>, здесь же коснемся самого основного.</p>

<p>Откроем файл <strong>package.json</strong> и отредактируем фрагмент настроек <strong>lint-staged</strong> следующим образом:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JSON</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="json">"lint-staged": {
  "*": "editorconfig-checker --exclude '.git|.husky|node_modules|.eslintcache'",
  "*.scss": "stylelint --fix",
  "*.js": [
    "eslint --cache --fix",
    "prettier --write"
  ]
}</code></pre>
  </div>
</div>

<h3 id="создание-editorconfig">Создание .editorconfig</h3>

<p>В корне проекта создадим файл <strong>.editorconfig</strong>, в нем мы будем задавать правила того как редактор кода, <strong>IDE</strong> должны стандартизировать содержимое файлов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.EDITORCONFIG</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".editorconfig">root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
end_of_line = lf
trim_trailing_whitespace = true
insert_final_newline = true

[*.{md,json}]
trim_trailing_whitespace = false</code></pre>
  </div>
</div>

<h3 id="создание-prettierrc">Создание .prettierrc</h3>

<p>В корне проекта создадим файл <strong>.prettierrc</strong>, в нем мы будем задавать дополнительные правила того как редактор кода, <strong>IDE</strong> должны стандартизировать содержимое <strong>js</strong> файлов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.PRETTIERRC</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".prettierrc">{
  "singleQuote": true,
  "printWidth": 120,
  "semi": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false,
  "endOfLine": "lf",
  "bracketSpacing": true,
  "arrowParens": "avoid"
}</code></pre>
  </div>
</div>

<h3 id="создание-stylelintrc">Создание .stylelintrc</h3>

<p>В корне проекта создадим файл <strong>.stylelintrc</strong>, в нем мы будем задавать дополнительные правила того как редактор кода, <strong>IDE</strong> должны стандартизировать содержимое <strong>scss</strong> файлов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.STYLELINTRC</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".stylelintrc">{
  "extends": [
    "stylelint-config-recommended-scss",
    "stylelint-config-rational-order"
  ],
  "plugins": [
    "stylelint-scss"
  ],
  "rules": {
    "at-rule-no-unknown": null,
    "scss/at-if-no-null": null,
    "scss/at-rule-no-unknown": [
      true,
      {
        "ignoreAtRules": [
          "tailwind"
        ]
      }
    ],
    "declaration-empty-line-before": null,
    "order/properties-order": [],
    "plugin/rational-order": [
      true,
      {
        "empty-line-between-groups": true
      }
    ],
    "no-descending-specificity": null,
    "block-no-empty": null,
    "import-notation": null,
    "string-quotes": "double",
    "selector-class-pattern": "^(?:(?:o|c|u|t|s|is|has|_|js|qa)-)?[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*(?:__[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*)?(?:--[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*)?(?:\\[.+\\])?$",
    "selector-no-vendor-prefix": null,
    "scss/no-global-function-names": null
  }
}</code></pre>
  </div>
</div>

<h3 id="создание-eslintrcjs">Создание .eslintrc.js</h3>

<p>В корне проекта создадим файл <strong>.eslintrc</strong>, в нем мы будем задавать дополнительные правила того как редактор кода, <strong>IDE</strong> должны стандартизировать содержимое <strong>js</strong> файлов.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">.ESLINTRC</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class=".eslintrc">module.exports = {
  root: true,
  env: {
    browser: true,
    es2023: true,
    node: true,
  },
  extends: ['airbnb-base', 'prettier'],
  parser: '@babel/eslint-parser',
  rules: {
    indent: ['off', 2, { MemberExpression: 'off' }],
    'no-var': 'error',
    'no-extra-semi': 'warn',
    'comma-dangle': ['error', 'always-multiline'],
    'computed-property-spacing': 'warn',
    'no-mixed-spaces-and-tabs': 'warn',
    'one-var': [
      'error',
      {
        var: 'never',
        let: 'never',
        const: 'never',
      },
    ],
    'unicode-bom': 'warn',
    'object-curly-spacing': ['error', 'always'],
    'class-methods-use-this': 'off',
    'default-param-last': 'off',
    'new-cap': ['error', { properties: false }],
    'no-plusplus': 'off',
    'no-prototype-builtins': 'off',
    'no-restricted-syntax': 'off',
    'no-nested-ternary': 'warn',
    'no-obj-calls': 'warn',
    'no-undefined': 'off',
    'object-curly-newline': 'off',
    'no-return-assign': 'off',
    'import/prefer-default-export': 'off',
    'max-len': 'off',
    'no-multi-assign': 'off',
    'no-unused-vars': 'error',
    'no-undef': 'off',
    'no-console': 'error',
    quotes: [2, 'single'],
    'import/no-dynamic-require': 'off',
    'global-require': 'off',
    semi: ['error', 'never'],
    'arrow-parens': ['error', 'as-needed'],
    'no-underscore-dangle': 'off',
    'no-use-before-define': 'off',
    'no-useless-return': 'off',
    'no-param-reassign': 'off',
    'no-new': 'off',
  },
  settings: {
    'import/resolver': {
      webpack: {
        config: 'webpack.config.js',
      },
    },
  },
}</code></pre>
  </div>
</div>

<h3 id="создание-eslintignore">Создание .eslintignore</h3>

<p>В корне проекта создадим файл <strong>.eslintignore</strong>. Он будет использоваться для указания файлов и каталогов, которые необходимо игнорировать во время анализа <strong>ESLint</strong>.</p>

<p>Изначальное содержимое файла <strong>.eslintignore</strong> будет пустым.</p>

<h3 id="создание-stylelintignore">Создание .stylelintignore</h3>

<p>В корне проекта создадим файл <strong>.stylelintignore</strong>. Он будет использоваться для указания файлов и каталогов, которые необходимо игнорировать во время анализа <strong>Stylelint</strong>.</p>

<p>Изначальное содержимое файла <strong>.stylelintignore</strong> будет пустым.</p>

<h3 id="создание-prettierignore">Создание .prettierignore</h3>

<p>В корне проекта создадим файл <strong>.prettierignore</strong>. Он будет использоваться для указания файлов и каталогов, которые необходимо игнорировать во время анализа <strong>JavaScript</strong>.</p>

<p>Изначальное содержимое файла <strong>.prettierignore</strong> будет пустым.</p>

<h2 id="webpack"><span class="attention">Установка</span> Webpack</h2>

<p><strong>Webpack</strong> - это инструмент сборки для веб-разработки, который позволяет разработчикам объединять, управлять и оптимизировать ресурсы, такие как <strong>JavaScript</strong>, <strong>CSS</strong>, изображения и многое другое, в один или несколько пакетов (<strong>bundles</strong>).</p>

<h3 id="основные-зависимости">Основные зависимости</h3>

<p>Установим базовые зависимости.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D webpack webpack-cli webpack-dev-server webpack-merge dotenv glob-all cross-env</code></pre>
  </div>
</div>

<p><strong>webpack</strong> - непосредственно само ядро сборщика. Предоставляет инструменты для определения и настройки процесса сборки, включая загрузчики (loaders) и плагины (plugins), для преобразования и оптимизации ресурсов.</p>

<p><strong>webpack-cli</strong> - этот пакет предоставляет интерфейс командной строки для работы с Webpack. Он позволяет разработчикам управлять процессом сборки, запускать сборку, указывать параметры и опции, а также выполнять различные задачи, связанные с сборкой проекта, такие как создание пакетов, запуск сервера разработки и другие.</p>

<p><strong>webpack-dev-server</strong> - этот пакет представляет собой инструмент для локальной разработки веб-приложений. Он позволяет создавать и запускать локальный веб-сервер, который автоматически перезагружает приложение при изменениях в исходном коде. Это упрощает процесс разработки, поскольку разработчики могут видеть результаты своей работы в реальном времени без необходимости каждый раз вручную пересобирать и перезапускать проект.</p>

<p><strong>webpack-merge</strong> - это пакет для объединения конфигураций Webpack. Он часто используется в проектах, где требуется разделение конфигурации на несколько файлов (например, один файл для разработки и другой для продакшена) или когда необходимо объединить различные части конфигурации из разных источников.</p>

<p><strong>dotenv</strong> - это пакет используются в приложении для хранения конфиденциальных данных, настроек и другой информации, которая может изменяться в разных средах, таких как разработка, тестирование и продакшн.</p>

<p><strong>glob-all</strong> - это пакет предназначенный для выполнения сложных операций над наборами файлов, включая копирование, удаление, обработку и другие манипуляции.</p>

<p><strong>cross-env</strong> - это удобная утилита командной строки, которая предназначена для устранения различий в командной оболочке между разными операционными системами. Она часто используется в сценариях сборки и запуска <strong>JavaScript</strong> проектов, где необходимо задавать переменные окружения и выполнять скрипты, независимо от операционной системы.</p>

<h3 id="обработчики-ресурсов-загрузчики">Обработчики ресурсов (загрузчики)</h3>

<p>Обработчики ресурсов играют важную роль в обработке различных типов файлов и ресурсов в вашем проекте. Они представляют собой функции или модули, которые используются для преобразования файлов веб-приложения перед тем, как они будут включены в сборку.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D mini-css-extract-plugin style-loader css-loader postcss-loader autoprefixer sass sass-loader file-loader babel-loader image-webpack-loader</code></pre>
  </div>
</div>

<p><strong>mini-css-extract-plugin</strong> - этот плагин извлекает стили из <strong>JavaScript</strong> файлов и сохраняет их в отдельные <strong>CSS</strong> файлы. Это улучшает производительность и кэширование, так как стили загружаются параллельно с <strong>JavaScript</strong>.</p>

<p><strong>style-loader</strong> - этот загрузчик внедряет стили непосредственно в <strong>HTML</strong> документ с использованием тегов <strong>&lt;style&gt;</strong>. Это полезно для разработки, но менее эффективно в продакшн среде, поскольку это может замедлить начальную загрузку страницы.</p>

<p><strong>css-loader</strong> - этот загрузчик позволяет <strong>Webpack</strong> понимать и импортировать файлы <strong>CSS</strong> в вашем <strong>JavaScript</strong> коде. Он также позволяет решать проблемы, такие как обработка импортов, <strong>CSS</strong> модулей и минимизация <strong>CSS</strong>.</p>

<p><strong>postcss-loader</strong> - этот загрузчик используется для автоматической обработки <strong>CSS</strong> с использованием <strong>PostCSS</strong>. Вы можете использовать его для автопрефиксации, оптимизации <strong>CSS</strong>, поддержки новых возможностей <strong>CSS</strong> и многого другого.</p>

<p><strong>autoprefixer</strong> - этот загрузчик добавляет вендорные префиксы к CSS-свойствам и значкам, чтобы обеспечить совместимость с различными браузерами.</p>

<p><strong>sass</strong> - само ядро предпроцессора sass.</p>

<p><strong>sass-loader</strong> - этот загрузчик преобразует файлы <strong>SASS</strong> или <strong>SCSS</strong> в обычные <strong>CSS</strong>.</p>

<p><strong>file-loader</strong> - этот загрузчик позволяет импортировать и обрабатывать файлы, такие как изображения, в вашем <strong>JavaScript</strong> коде. Он может переносить файлы и предоставлять url к ним.</p>

<p><strong>babel-loader</strong> - этот загрузчик преобразует современный <strong>JavaScript</strong> (<strong>ES6+</strong>) в старый <strong>JavaScript</strong> (<strong>ES5</strong>), который совместим с большинством браузеров. Он позволяет использовать современный синтаксис и возможности языка в вашем коде и обеспечивает поддержку различных плагинов и пресетов <strong>Babel</strong>.</p>

<p><strong>image-webpack-loader</strong> - этот загрузчик оптимизирует изображения.</p>

<h3 id="плагины">Плагины</h3>

<p>Плагины позволяют выполнять различные дополнительные задачи при сборке проекта, предоставляют более широкие и гибкие возможности, чем загрузчики (loaders), и могут использоваться для различных целей, таких как оптимизация, минификация, управление ресурсами, создание HTML-страниц, инжекция зависимостей, генерация исходных карт и многое другое.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">npm i -D clean-webpack-plugin html-webpack-plugin mini-css-extract-plugin svg-sprite-html-webpack svg-inline-loader copy-webpack-plugin terser-webpack-plugin purgecss-webpack-plugin</code></pre>
  </div>
</div>

<p><strong>clean-webpack-plugin</strong> - это предназначен для удаления файлов и каталогов во время сборки проекта. Этот плагин полезен, когда вы хотите гарантировать, что во время каждой новой сборки вашего проекта старые файлы и каталоги будут удалены, предотвращая накопление мусора.</p>

<p><strong>html-webpack-plugin</strong> - этот плагин позволяет автоматически создавать <strong>HTML</strong> файл, который будет включать в себя ссылки на все сгенерированные <strong>JavaScript</strong> и <strong>CSS</strong> файлы.</p>

<p><strong>mini-css-extract-plugin</strong> - этот плагин позволяет извлекать <strong>CSS</strong> код из <strong>JavaScript</strong> файлов и сохранять его в отдельных <strong>CSS</strong> файлах.</p>

<p><strong>svg-sprite-html-webpack</strong> - этот плагин создает спрайт из <strong>svg</strong> иконок.</p>

<p><strong>svg-inline-loader</strong> - этот плагин позволяет подключать файлы по ссылке до них, например в <strong>css</strong> файле.</p>

<p><strong>copy-webpack-plugin</strong> - этот плагин позволяет копировать файлы и директории из одного места в другое в процессе сборки.</p>

<p><strong>terser-webpack-plugin</strong> - этот плагин выполняет минимизацию и оптимизацию <strong>JavaScript</strong> кода, уменьшая его размер и улучшая производительность веб-приложения.</p>

<p><strong>purgecss-webpack-plugin</strong> - этот плагин предназначен для удаления неиспользуемых стилей из ваших <strong>CSS</strong> файлов. Это позволяет уменьшить размер <strong>CSS</strong> файлов и улучшить производительность загрузки страницы.</p>

<h2 id="webpack-settings"><span class="attention">Настройка</span> Webpack</h2>

<p>В процессе написания конфигураций для сборщика <strong>webpack</strong> мы разделим логику для разработки (<strong>developer</strong>) и готовой версией (<strong>production</strong>), чтобы сократить дублирования и улучшить дальнейшее сопровождение кода.</p>

<p>В корне фреймворка создадим файл <strong>webpack.config.js</strong>, данный файл будет отправной точкой для отслеживания путей до файлов проекта. Благодаря его настройкам и прописанному правилу <strong>import/resolver</strong> в файле <strong>.eslintrc.js</strong> редактор кода или IDE будут понимать где искать файл, в прописанных путях. <strong>Например:</strong> вместо <strong>../../components</strong> мы сможем указать более читаемый путь <strong>@/components</strong>.</p>

<p>Содержимое файла <strong>webpack.config.js</strong> будет следующим:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const { resolve } = require('path') // работа с путями к файлам и каталогам

module.exports = {
  resolve: {
    extensions: ['.js'],

    // короткий путь до js файлов через символ @, например @/components/ButtonComponent
    // поиск файлов будет производиться в каталоге src
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
}</code></pre>
  </div>
</div>

<p>Далее в корне проекта создадим каталог <strong>webpack</strong>. Внутри данного каталога создадим следующую структуру:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./webpack
├── loaders
├── webpack.common.js
├── webpack.dev.js
└── webpack.prod.js</code></pre>
  </div>
</div>

<p><strong>loaders</strong> - данный каталог будет хранить <strong>webpack</strong> модули для обработки ресурсов во время сборки проекта.</p>

<p><strong>webpack.common.js</strong> - конфигурационный файл, отвечающий за общую логику как для <strong>developer</strong>, так и для <strong>production</strong> версии.</p>

<p><strong>webpack.dev.js</strong> - конфигурационный файл, отвечающий за логику <strong>developer</strong> версии.</p>

<p><strong>webpack.prod.js</strong> - конфигурационный файл, отвечающий за логику <strong>production</strong> версии.</p>

<h3 id="описание-файла-webpackcommonjs">Описание файла webpack.common.js</h3>

<p>Откроем файл <strong>webpack.common.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const { join } = require('path') // работа с путями к файлам и каталогам
const webpack = require('webpack') // ядро webpack
const { merge } = require('webpack-merge') // объединяет конфигурации

const HtmlWebpackPlugin = require('html-webpack-plugin') // динамически встраивает данные в html
const MiniCssExtractPlugin = require('mini-css-extract-plugin') // сохраняет css и js в отдельные файлы
const CopyWebpackPlugin = require('copy-webpack-plugin') // копирует файлы и директории из одного места в другое
const SvgSpriteHtmlWebpackPlugin = require('svg-sprite-html-webpack') // создает svg спрайт

const jsLoaders = require('./loaders/js-loaders') // обработка js
const cssLoaders = require('./loaders/css-loaders') // обработка стилей
const imageLoaders = require('./loaders/image-loaders') // обработка изображений
const fontLoaders = require('./loaders/font-loaders') // обработка шрифтов

const webpackBase = require('../webpack.config') // базовый конфигурационный файл

// загрузка переменных окружения
require('dotenv').config({
  path: `${process.env.NODE_ENV}.env`, // путь до файла .env, например development.env или production.env
})

module.exports = merge(webpackBase, {
  target: 'web', // целевая среду сборки браузер

  // входная точка
  entry: {
    app: join(__dirname, '../src/main.js'), // основной JavaScript файл приложения
  },

  // исходная точка
  output: {
    publicPath: '/', // публичный путь для доступа к выходным файлам
    path: join(__dirname, '../dist'), // директория для сохранения собранных файлов
    filename: 'js/[name].bundle.js', // имя выходного файла с динамическими именами [name]
    chunkFilename: 'js/[name]-[id].js', // имя файлов чанков с динамическими именами [name]-[id]
    clean: true, // очистка выходной директории перед каждой сборкой
  },

  // дополнительные модули для обработки файлов
  module: {
    rules: [
      // правило для обработки изображений
      {
        test: /\.(png|jpe?g|gif|webp)$/i,
        use: imageLoaders,
      },

      // вместо данной конструкции будет использоваться asset/inline,
      // приведенное ниже правило
      // {
      //   test: /\.svg$/,
      //   use: SvgSpriteHtmlWebpackPlugin.getLoader(),
      //   exclude: /node_modules/,
      // },

      // встроенные ресурсы
      // background: url("@/assets/icons/icon-blank.svg")
      {
        test: /\.svg$/,
        type: 'asset/inline',
        resourceQuery: /inline/,
      },

      // правило для обработки шрифтов
      {
        test: /\.(woff2)$/i,
        use: fontLoaders,
      },

      // правило для обработки css модулей
      {
        test: /\.(sa|sc|c)ss$/i,
        use: cssLoaders.map(item =&gt; {
          const clone = { ...item }

          if (clone.loader === 'css-loader') {
            clone.options = {
              modules: true, // включение CSS модулей для css-loader
            }
          }

          return clone
        }),
        include: /\.module\.css$/, // применяется только к файлам с расширением .module.css
      },

      // правило для обработки стилей
      {
        test: /\.(sa|sc|c)ss$/i,
        use: cssLoaders,
        exclude: /\.module\.css$/, // исключение файлов с расширением .module.css.
      },

      // правило для обработки скриптов
      {
        test: /\.m?js$/i,
        use: jsLoaders,
        exclude: /node_modules/, // исключение файлов из node_modules
      },
    ],
  },

  // плагины webpack
  plugins: [
    // определение переменных окружения
    new webpack.DefinePlugin({
      // API_URL будет взять с подключенного файла development.env или production.env
      // Далее в коде проекта переменная process.env.API_URL при сборки заменится на свое значение
      'process.env.API_URL': JSON.stringify(process.env.API_URL),
    }),

    // создание HTML файла на основе шаблона
    new HtmlWebpackPlugin({
      filename: 'index.html', // имя HTML файла
      template: join(__dirname, '../src/index.html'), // шаблон основного index.html файла
    }),

    // извлечение стилей в отдельные CSS файлы
    new MiniCssExtractPlugin({
      filename: 'css/[name].css', // имя CSS файла
      chunkFilename: 'css/[id].css', // имя файлов чанков стилей
    }),

    // svg спрайт
    // пример: &lt;svg&gt; &lt;use xlink:href="#icon-test"&gt;&lt;/use&gt; &lt;/svg&gt;
    new SvgSpriteHtmlWebpackPlugin({
      append: false, // вставить спрайт вначале &lt;body&gt; для false
      includeFiles: [
        'src/assets/icons/*.svg', // подключаемые в спрайт файлы
      ],
    }),

    // копирование файлов и ресурсов
    new CopyWebpackPlugin({
      patterns: [
        {
          from: join(__dirname, '../src/assets'), // откуда копировать
          to: 'assets/[path][name][ext]', // куда копировать
          noErrorOnMissing: true, // не генерировать ошибки при отсутствии файлов
        },
      ],
    }),
  ],
})</code></pre>
  </div>
</div>

<h3 id="обработчики-ресурсов">Обработчики ресурсов</h3>

<p>Описывая содержимое файла <strong>webpack.common.js</strong> была добавлена конструкция, которая подключает файлы <strong>loaders</strong>. Данные файлы не что иное, как вынесенная логика обработки различных форматов файлов такие как <strong>css</strong>, <strong>images</strong> и т.д. в отдельные файлы.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const jsLoaders = require('./loaders/js-loaders') // обработка js
const cssLoaders = require('./loaders/css-loaders') // обработка стилей
const imageLoaders = require('./loaders/image-loaders') // обработка изображений
const fontLoaders = require('./loaders/font-loaders') // обработка шрифтов</code></pre>
  </div>
</div>

<p>Создадим эти файлы внутри каталога <strong>loaders</strong> и опишем их:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./loaders
├── js-loaders.js
├── css-loaders.js
├── font-loaders.js
└── image-loaders.js</code></pre>
  </div>
</div>

<h3 id="описание-файла-js-loadersjs">Описание файла js-loaders.js</h3>

<p>Откроем файл <strong>js-loaders.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">module.exports = [
  {
    loader: 'babel-loader', // преобразование es6+ в es5
  },
]</code></pre>
  </div>
</div>

<h3 id="описание-файла-css-loadersjs">Описание файла css-loaders.js</h3>

<p>Откроем файл <strong>css-loaders.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const MiniCssExtractPlugin = require('mini-css-extract-plugin') // извлекать css из js

const devMode = process.env.NODE_ENV === 'development' // определение окружения

module.exports = [
  devMode ? { loader: 'style-loader' } : { loader: MiniCssExtractPlugin.loader }, // инлайн стили или стили в отдельный файл
  { loader: 'css-loader' }, // поддержка css файлов
  { loader: 'postcss-loader' }, // автопрефиксер и другие улучшения
  { loader: 'sass-loader' }, // поддержка scss файлов
]</code></pre>
  </div>
</div>

<p>Здесь подключили различные загрузчики, которые обрабатывают <strong>css</strong> стили, в числе которых присутствует <strong>postcss-loader</strong>. Это мощный инструмент позволяет подключить множество дополнительных расширений, которые улучшат опыт взаимодействия со стилями.</p>

<p>Для того чтобы иметь возможность подключать в <strong>postcss-loader</strong> различные расширения, создадим в корне проекта файл <strong>postcss.config.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">module.exports = {
  plugins: [
    require('autoprefixer'), // добавляет вендорные префексы браузеров к стилям
  ],
}</code></pre>
  </div>
</div>

<p>В данном случае был подключен <strong>autoprefixer</strong>, но ничто не мешает добавлять и другие требуемые расширения.</p>

<h3 id="описание-файла-font-loadersjs">Описание файла font-loaders.js</h3>

<p>Откроем файл <strong>font-loaders.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">module.exports = [
  {
    loader: 'file-loader', // импорт и обработка файлов
    options: {
      outputPath: 'fonts', // каталог куда будет происходить импорт
    },
  },
]</code></pre>
  </div>
</div>

<h3 id="описание-файла-image-loadersjs">Описание файла image-loaders.js</h3>

<p>Откроем файл <strong>image-loaders.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">module.exports = [
  {
    loader: 'file-loader', // импорт и обработка файлов
    options: {
      name: '[path][name].[ext]', // имя файла
    },
  },
  {
    loader: 'image-webpack-loader', // оптимизация изображений
    options: {
      mozjpeg: {
        progressive: true,
      },
      optipng: {
        enabled: true,
      },
      pngquant: {
        quality: [0.65, 0.90],
        speed: 4,
      },
      gifsicle: {
        interlaced: false,
      },
      webp: {
        quality: 75,
      },
    },
  },
]</code></pre>
  </div>
</div>

<h3 id="переменные-окружения">Переменные окружения</h3>

<p>В файле <strong>webpack.common.js</strong> был заложен фундамент для использования переменных окружений, а именно благодаря следующим блокам кода:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">// загрузка переменных окружения
require('dotenv').config({
  path: `${process.env.NODE_ENV}.env`, // путь до файла .env, например development.env или production.env
})

...

// определение переменных окружения
new webpack.DefinePlugin({
  // API_URL будет взять с подключенного файла development.env или production.env
  // Далее в коде проекта переменная process.env.API_URL при сборки заменится на свое значение
  'process.env.API_URL': JSON.stringify(process.env.API_URL),
}),</code></pre>
  </div>
</div>

<p>Теперь необходимо создать сами файлы, хранящие переменные окружения. Для этого в корне проекта создадим два файла:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./
├── development.env
└── production.env</code></pre>
  </div>
</div>

<p>Внутри данных файлов для примера добавим одну переменную, в разработке этих переменных может быть столько сколько необходимо.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">ENV</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="env">API_URL=https://example.com</code></pre>
  </div>
</div>

<p>Теперь добавим правила для запуска сборки, которые будут собирать наш фрэймворк в режиме <strong>developer</strong> или <strong>production</strong>. Для этого отредактируем содержимое файла <strong>package.json</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JSON</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="json">"scripts": {
  "prepare": "husky install",
  "develop": "cross-env NODE_ENV=development webpack serve --config webpack/webpack.dev.js",
  "build": "cross-env NODE_ENV=production webpack --config webpack/webpack.prod.js"
},</code></pre>
  </div>
</div>

<p>Здесь мы добавили в секцию <strong>scripts</strong> правила <strong>develop</strong> и <strong>build</strong>.</p>

<p><strong>develop</strong> - запускает сборку в режиме разработки, позволяя изменять код и видеть изменения в браузере <br />
<strong>build</strong> - собирает сборку в готовый проект, который можно выгрузить на хостинг</p>

<p>Команда <strong>cross-env NODE_ENV=development</strong> создает переменную <strong>NODE_ENV</strong> с содержимым <strong>development</strong> к которой далее в коде мы можем обращаться.</p>

<p><strong>webpack serve</strong> позволяет запустить сборку и поднять локальный сервер который отобразит сайт в браузере.</p>

<p><strong>–config webpack/webpack.dev.js</strong> запускает сборку с настройками прописанными в файле <strong>webpack.dev.js</strong>.</p>

<p>По аналогии тоже самое происходит в <strong>build</strong> режиме за исключением некоторых изменений.</p>

<h3 id="описание-файла-webpackdevjs">Описание файла webpack.dev.js</h3>

<p>Откроем файл <strong>webpack.dev.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const { join } = require('path') // работа с путями к файлам и каталогам
const { merge } = require('webpack-merge') // объединяет конфигурации
const { CleanWebpackPlugin } = require('clean-webpack-plugin') // удаляет файлы и каталоги перед каждой сборкой

const common = require('./webpack.common') // общие конфигурации для dev и prod версий

module.exports = merge(common, {
  mode: 'development', // режим разработки
  devtool: 'inline-source-map', // устанавливаем source map для отладки (eval-cheap-module-source-map)
  devServer: { // настройки для сервера разработки
    port: 3003, // порт
    hot: true, // вносит изменения в код приложения без перекомпиляции всего проекта
    compress: true, // сжатие данных
    https: true, // использование https
    historyApiFallback: true, // поддержка HTML5 History API
    static: {
      directory: join(__dirname, '../dist') // указываем путь к статическим файлам
    },
    devMiddleware: { // позволяет моментально видеть изменения
      index: true, // автоматически отображение индексного файла
      publicPath: '/', // базовый url для сервера разработки
      writeToDisk: true, // исходные карты и ресурсы будут записаны на диск
    },
    client: {
      logging: 'log' // логи будут отображаться в консоли браузера
    },
  },
  plugins: [ // плагины webpack
    new CleanWebpackPlugin({ // очистка указанных файлов и каталогов перед сборкой
      cleanOnceBeforeBuildPatterns: [
        join(__dirname, '../dist')
      ]
    })
  ]
})</code></pre>
  </div>
</div>

<h3 id="описание-файла-webpackprodjs">Описание файла webpack.prod.js</h3>

<p>Откроем файл <strong>webpack.prod.js</strong> и пропишем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const { join, resolve } = require('path') // работа с путями к файлам и каталогам
const globAll = require('glob-all') // операции над файлами
const { merge } = require('webpack-merge') // объединяет конфигурации

const TerserPlugin = require('terser-webpack-plugin') // выполняет минимизацию и оптимизацию js
const { PurgeCSSPlugin } = require('purgecss-webpack-plugin') // удаляет неиспользуемые css стили

const common = require('./webpack.common') // общие конфигурации для dev и prod версий

module.exports = merge(common, {
  mode: 'production', // режим production
  output: {
    // исходная точка
    publicPath: '/', // публичный путь для доступа к выходным файлам
    path: resolve(__dirname, '../build'), // устанавливает путь для сохранения собранного кода
    filename: 'js/[name].[contenthash].js', // настройка имени собранного файла с хэшем содержимого
    clean: true, // очистка каталога сборки перед каждой новой сборкой
  },
  optimization: {
    // настройки для оптимизации сборки
    minimizer: [
      new TerserPlugin({
        parallel: true, // параллельная минимизация для ускорения сборки
        extractComments: false, // не извлекать комментарии из сжатого кода
        terserOptions: {
          format: {
            comments: false, // не сохранять комментарии
          },
        },
      }),
    ],
  },
  plugins: [
    new PurgeCSSPlugin({
      paths: globAll.sync(join(__dirname, '../src/**/*.js'), { nodir: true }), // пути к js файлам для анализа стилей
    }),
  ],
})</code></pre>
  </div>
</div>

<h2 id="structure"><span class="attention">Структура</span> проекта</h2>

<p>Опишем структуру фреймворка, в нашем случае будет использована самая простая классическая файловая структура без какой-либо сложной архитектуры на подобии <strong>FSD</strong>.</p>

<p>Первое что нам понадобится это создать в корне проекта каталог <strong>src</strong> и внутри него будут находиться все исходники фреймворка.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./src
├── assets
│    ├── favicons
│    ├── icons
│    └── scss
├── core
├── components
├── pages
├── layouts
├── reducers
├── routers
├── services
├── store
├── utils
├── main.js
└── index.html</code></pre>
  </div>
</div>

<p><strong>assets</strong> - содержит различные иконки, картинки, общие стили, и т.п.</p>

<p><strong>core</strong> - ядро нашего фреймворка</p>

<p><strong>components</strong> - отдельные компоненты проектам</p>

<p><strong>pages</strong> - страницы проекта</p>

<p><strong>layouts</strong> - общий шаблон для всех страниц проекта, содержит повторяющиеся части от страницы к странице, например шапка, подвал сайта</p>

<p><strong>reducers</strong> - содержит логику по управлению состоянием в проекте</p>

<p><strong>routers</strong> - содержит маршруты проекта</p>

<p><strong>services</strong> - содержит api для подключения к сторонним ресурсам</p>

<p><strong>store</strong> - содержит state проекта, связан с <strong>reducers</strong></p>

<p><strong>utils</strong> - содержит вспомогательные пользовательские функции</p>

<p><strong>main.js</strong> - основной файл запускающий программную часть проекта</p>

<p><strong>index.html</strong> - основной файл отображающий проект в браузере</p>

<h2 id="base-settings"><span class="attention">Базовая</span> настройка проекта</h2>

<p>Прежде чем приступить к написанию движка нашего будущего фреймворка начнем с описания файла <strong>index.html</strong> и связанных с ним <strong>assets</strong> файлов.</p>

<h3 id="описание-файла-indexhtml">Описание файла index.html</h3>

<p>Откроем файл <strong>index.html</strong> и введем в него следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">HTML</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="ru"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Главная страница&lt;/title&gt;

    &lt;meta name="theme-color" content="#000"&gt;
    &lt;meta name="msapplication-TileColor" content="#000"&gt;

    &lt;link rel="icon" href="/assets/favicons/favicon.ico" sizes="any"&gt;
    &lt;link rel="icon" href="/assets/favicons/icon.svg" type="image/svg+xml"&gt;
    &lt;link rel="apple-touch-icon" href="/assets/favicons/apple-touch-icon.png"&gt;
    &lt;link rel="manifest" href="/assets/favicons/manifest.json"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
  </div>
</div>

<h3 id="описание-структуры-favicons">Описание структуры favicons</h3>

<p>Добавим в каталог <strong>./src/assets/favicons</strong> следующие файлы:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./src/assets/favicons/
├── apple-touch-icon.png
├── favicon.ico
├── icon-192.png
├── icon-512.png
├── icon.svg
└── manifest.json</code></pre>
  </div>
</div>

<p><strong>Favicons будут иметь следующие разрешения:</strong></p>

<p><strong>apple-touch-icon.png</strong> - 180 на 180 <br />
<strong>favicon.ico</strong> - 32 на 32 <br />
<strong>icon-192.png</strong> - 192 на 192 <br />
<strong>icon-512</strong> - 512 на 512 <br />
<strong>icon.svg</strong> - svg иконка для любого другого изображения</p>

<h4 id="опишем-содержимое-файла-manifestjson">Опишем содержимое файла <strong>manifest.json</strong>:</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JSON</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="json">{
  "name": "JavaScript framework",
  "short_name": "JavaScript framework",
  "description": "JavaScript framework для создания spa приложений",
  "lang": "ru",
  "dir": "ltr",
  "id": "/",
  "start_url": "/",
  "scope": "/",
  "display": "minimal-ui",
  "orientation": "any",
  "theme_color": "#000",
  "background_color": "#000",
  "prefer_related_applications": false,
  "icons": [
    {
      "src": "icon-192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "icon-512.png",
      "type": "image/png",
      "sizes": "512x512"
    },
    {
      "src": "icon.svg",
      "sizes": "any",
      "type": "image/svg",
      "purpose": "maskable"
    }
  ]
}</code></pre>
  </div>
</div>

<h3 id="описание-структуры-scss">Описание структуры scss</h3>

<p>Добавим в каталог <strong>./src/assets/scss</strong> следующие файлы:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./src/assets/scss/
├── global.scss
├── mixin.scss
└── variable.scss</code></pre>
  </div>
</div>

<p><strong>global.scss</strong> - содержит глобальные стили для всего проекта <br />
<strong>mixin.scss</strong> - содержит пользовательские scss миксины <br />
<strong>variable.scss</strong> - содержит пользовательские scss переменные</p>

<h4 id="опишем-содержимое-файла-globalscss">Опишем содержимое файла <strong>global.scss</strong>:</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">SCSS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="scss">@import "variable";

*,
*::before,
*::after {
  box-sizing: inherit;
}

html,
body {
  height: 100vh;
}

html {
  box-sizing: border-box;
}

body {
  position: relative;

  min-width: 380px;
  margin: 0;

  color: $color-black;
  font-size: 16px;
  font-family: Arial, sans-serif;
  line-height: 1.5;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

  background-color: $color-grey;
}

img {
  max-width: 100%;
  height: auto;
}

#app {
  height: 100%;
}

.container {
  width: 100%;
  max-width: 1210px;
  margin: 0 auto;
  padding: 0 20px;
}

.sr-only {
  position: absolute;

  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;

  border: 0;

  clip: rect(0, 0, 0, 0);
  clip-path: inset(100%);
}

.active {
  color: red;
}</code></pre>
  </div>
</div>

<h4 id="опишем-содержимое-файла-mixinscss">Опишем содержимое файла <strong>mixin.scss</strong>:</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">SCSS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="scss">@mixin list-reset {
  margin: 0;
  padding: 0;

  list-style: none;
}</code></pre>
  </div>
</div>

<h4 id="опишем-содержимое-файла-variablescss">Опишем содержимое файла <strong>variable.scss</strong>:</h4>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">SCSS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="scss">$color-black: #222;
$color-white: #fff;
$color-red: #f31b2c;
$color-grey: #edf1f5;
$color-blue: #1c90e9;
$color-yellow: #ffdd56;</code></pre>
  </div>
</div>

<h3 id="описание-структуры-icons">Описание структуры icons</h3>

<p>Для примера добавим в каталог с иконками любой svg файл, например <strong>icon-heart.svg</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">SVG</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="svg">&lt;svg width="800" height="800" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;path
    d="M2 9.1371C2 14 6.01943 16.5914 8.96173 18.9109C10 19.7294 11 20.5 12 20.5C13 20.5 14 19.7294 15.0383 18.9109C17.9806 16.5914 22 14 22 9.1371C22 4.27416 16.4998 0.825464 12 5.50063C7.50016 0.825464 2 4.27416 2 9.1371Z"
    fill="currentColor"/&gt;
&lt;/svg&gt;</code></pre>
  </div>
</div>

<h3 id="завершение-базовой-настройки-проекта">Завершение базовой настройки проекта</h3>

<p>И так мы завершили базовую настройку проекта, пришло время приступить не посредственно к созданию самого ядра фреймворка.</p>

<h2 id="core"><span class="attention">Ядро</span> фреймворка</h2>

<p>Определимся с функциональностью нашего фреймворка. Я выделил следующие составляющие которые в процессе мы реализуем:</p>

<ul>
  <li><strong>Роутинг</strong> - фреймворк должен предоставлять механизм для маршрутизации, который позволяет управлять тем, как различные URL-адреса и маршруты в приложении соотносятся с компонентами и действиями.</li>
  <li><strong>Управление состоянием</strong> - возможность эффективно управлять состоянием приложения. Мы реализуем <strong>Redux</strong> подобное хранилище состояний.</li>
  <li><strong>Компоненты</strong> - фреймворк должен предоставлять инструменты для создания и взаимодействия с компонентами, позволяющими разделять интерфейс на более мелкие и переиспользуемые части.</li>
  <li><strong>HTTP запросы</strong> - механизм для выполнения запросов и обработки ответов с сервера. Это может включать в себя AJAX-запросы, работу с API и управление данными.</li>
  <li><strong>Шаблонизация</strong> - возможность генерации и рендеринга HTML-кода на основе шаблонов или компонентов.</li>
  <li><strong>События и обработка событий</strong> - механизм для обработки пользовательских событий, как клики, изменения ввода и другие.</li>
  <li><strong>Маршрутизация по компонентам</strong> - механизм для динамической загрузки и переключения между компонентами на основе URL-адреса и маршрутизации.</li>
</ul>

<h2 id="router"><span class="attention">Класс</span> Router</h2>

<p>Создадим в каталоге <strong>./src/routers</strong> файл <strong>index.js</strong>. Данный файл будет содержать маршруты нашего приложения. Можно по-разному придумать в каком виде хранить и каким образом регистрировать маршруты. В своем решении мне захотелось сделать это чем то напоминающим регистрацию маршрутов во <strong>Vue</strong>.</p>

<p>И так содержимое файла <strong>./src/routers/index.js</strong> будет следующим:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import Router from '@/core/Router/Router' // роутер фрейморка

/**
 * Регистрация роутов
 *
 * @type {*|null}
 */
const router = Router.createRoute({
  // Вид роутинга, в рамках фреймворка будут реализованы
  // два вида:
  // createWebHistory - стандартный роутинг, вида /foo/bar
  // createWebHashHistory - роутинг с хэшем, вида /#/foo/bar
  history: Router.createWebHistory(),

  // Список роутов
  // Здесь мы используем динамический импорт для улучшения производительности
  routes: [
    {
      path: '/', // ссылка на главную страницу
      component: import('@/pages/HomePage'), // класс отвечающий за отображение главной страницы
    },
    {
      path: '/about',
      component: import('@/pages/AboutPage'),
    },
    {
      path: '/.*', // 404 страница
      component: import('@/pages/ErrorPage'), // класс отвечающий за отображение 404 страницы
    },
  ],
})

export default router</code></pre>
  </div>
</div>

<p>Страница <strong>AboutPage</strong> нам пригодится, чтобы протестировать переход между страницами без перезагрузки страницы, а страница <strong>ErrorPage</strong> нужна для того чтобы при переходе по не зарегистрированному маршруту отображалась пользовательская страница 404.</p>

<p>Подключим созданный файл <strong>./src/routers/index.js</strong> в главный исполняемый файл нашего фреймворка <strong>main.js</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import router from '@/routers' // роутер приложения</code></pre>
  </div>
</div>

<p>Теперь приступим непосредственно к созданию <strong>Router</strong> для фреймворка. Для этого в каталоге <strong>./scr/core</strong> создадим каталог <strong>Router</strong>. Почему создается целый каталог вместо одного файла <strong>Router.js</strong> так как я предполагаю, что класс <strong>Router</strong> получится довольно большим и чтобы его немного разгрузить я создам некоторые другие файлы в которые вынесу часть логики файла <strong>Router</strong>. И так должна получиться следующая структура:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">BASH</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="bash">./src/core/Router/
├── Dispatcher.js
├── HistoryTypeEnum.js
└── Router.js</code></pre>
  </div>
</div>

<p><strong>Dispatcher.js</strong> - будет являться родительским классом для класса <strong>Router</strong>, будет содержать вспомогательные методы для <strong>Router</strong>.</p>

<p><strong>HistoryTypeEnum.js</strong> - будет содержать <strong>ENUM</strong> подобный объект, хранящий виды роутинга (обычный или с хэшем).</p>

<p><strong>Router.js</strong> - непосредственно сам роутинг, хранящий всю основную логику.</p>

<h3 id="описание-файла-historytypeenumjs">Описание файла HistoryTypeEnum.js</h3>

<p>Данный файл очень простым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">/**
 * Режимы истории
 *
 * @type {Readonly&lt;{STATE: string, HASH: string}&gt;}
 */
const HISTORY_TYPE_ENUM = Object.freeze({
  HASH: 'hashchange', // для ссылки с хэшем
  STATE: 'popstate', // для стандартной ссылки
})

export default HISTORY_TYPE_ENUM</code></pre>
  </div>
</div>

<h3 id="описание-файла-dispatcherjs">Описание файла Dispatcher.js</h3>

<p>Данный класс будет использовать паттерн <strong>Singleton</strong> для того, чтобы все созданные маршруты аккумулировались внутри одного объекта.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import HISTORY_TYPE_ENUM from '@/core/Router/HistoryTypeEnum' // виды роутинга

/**
 * Родительский класс для Router
 *
 * Содержит вспомогательные методы для Router.
 */
export default class Dispatcher {
  /**
   * Разрешение на создание экземпляра класса
   *
   * @type {boolean}
   * @protected
   */
  static _initializing = false

  /**
   * Экземпляр класса
   *
   * @type {null}
   * @protected
   */
  static _instance = null

  /**
   * Режим истории по умолчанию с использованием хэша
   *
   * @type {string}
   * @property
   */
  _history = HISTORY_TYPE_ENUM.HASH

  /**
   * Роуты
   *
   * @type {[]}
   * @property
   */
  _routes = []

  /**
   * Основной корневой элемент в который будет добавляться разметка
   *
   * @type {string}
   * @protected
   */
  _root = '#app'

  /**
   * Данный класс является абстрактным
   */
  constructor() {
    if (!Dispatcher._initializing) {
      throw new TypeError('Нельзя напрямую создать экземпляр данного класса')
    }
  }

  /**
   * Получение основного корневого элемента
   *
   * @returns {string}
   */
  get root() {
    return this._root
  }

  /**
   * Изменение основного корневого элемента
   *
   * @param selector
   */
  set root(selector) {
    this._root = selector
  }

  /**
   * Создание экземпляра класса
   *
   * @returns {*|null}
   */
  static get instance() {
    // Возвращаем объект данного класса если он был уже создан
    if (this._instance instanceof this) {
      return this._instance
    }

    // Если объект не был создан создаем его и возвращаем
    Dispatcher._initializing = true
    this._instance = new this()
    Dispatcher._initializing = false

    return this._instance
  }

  /**
   * Получить активный режим истории
   *
   * @returns {string}
   */
  get history() {
    return this._history
  }

  /**
   * Получить список всех роутов
   *
   * @returns {[]}
   */
  get routes() {
    return this._routes
  }

  /**
   * Режим роута с хэшем
   *
   * @returns {string}
   */
  static createWebHashHistory() {
    return HISTORY_TYPE_ENUM.HASH
  }

  /**
   * Режим роута стандартный
   *
   * @returns {string}
   */
  static createWebHistory() {
    return HISTORY_TYPE_ENUM.STATE
  }

  /**
   * Форматирование текущего адреса страницы для режима хэш
   *
   * @returns {string}
   * @protected
   */
  _strippedHashPath() {
    return `/${window.location.hash.replace(/^#\//, '')}` // '#/foo/bar' -&gt; '/foo/bar'
  }

  /**
   * Форматирование текущего адреса страницы в стандартном режиме
   *
   * @returns {string}
   * @protected
   */
  _strippedPath() {
    return `/${window.location.pathname
      .replace(/^\/+|\/+$/g, '') // '////foo/bar////' -&gt; 'foo/bar'
      .replace(/\/+/g, '/')}` // 'foo/////bar' -&gt; 'foo/bar'
  }
}</code></pre>
  </div>
</div>

<h3 id="описание-файла-routerjs">Описание файла Router.js</h3>

<p>Непосредственно сам роутер который берет на себя всю основную работу.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import Dispatcher from '@/core/Router/Dispatcher' // родительский класс
import HISTORY_TYPE_ENUM from '@/core/Router/HistoryTypeEnum' // виды роутинга

/**
 * Роутер
 *
 */
export default class Router extends Dispatcher {
  /**
   * Хранит область где будет располагаться разметка страницы
   *
   * @type {null}
   * @protected
   */
  _pageElement = null

  /**
   * Создание роутера
   *
   * @param history - вид роута
   * @param routes - маршруты
   * @returns {*|null}
   */
  static createRoute({ history, routes }) {
    // Получаем объект класса Router
    const router = Router.instance

    // Определяем режим навигации по сайту
    router._history = history ?? router._history

    // Получаем зарегистрированные маршруты
    router._routes.push(...routes)

    // Возвращаем объект класса Router
    return router
  }

  /**
   * Отрисовка готовой страницы
   *
   * @returns {Promise&lt;void&gt;}
   */
  render = async () =&gt; {
    // Находим нужный роут и получаем его component,
    // то что прописано при регистрации роутов.
    // Например: component: import('@/pages/ProductPage')
    const { component } = this._findRoute(this.getUri())

    // Если роутер не был найден выводим служебную
    // 404 страницу об ошибке.
    // Для того чтобы выводилась пользовательская страница 404,
    // при перечислении маршрутов в самом конце списка нужно указать:
    // path: '/.*' и component: import('@/pages/ErrorPage').
    // Далее уже в файле ErrorPage описать как будет выглядеть страница об ошибках.
    if (!component) {
      this._page404()

      return
    }

    // Получаем параметры страницы
    const params = this._getParams()

    // Получаем саму страницу
    const page = await this._getComponent(component, params)

    // Если у страницы задан шаблон, то рендерим шаблон.
    if (page.layout) {
      await this._renderLayout(page.layout)
    } else {
      this._pageElement = null
    }

    // Рендерим страницу
    await this._renderPage(page)
  }

  /**
   * Рендер шаблона страницы
   *
   * @param layout - import('@/layouts/MainLayout')
   * @returns {Promise&lt;void&gt;}
   * @protected
   */
  _renderLayout = async layout =&gt; {
    // Страница будет содержать путь до шаблона вида import('@/layouts/MainLayout'),
    // при создании объекта этого класса MainLayout нужно взять саму разметку шаблона
    // и разметку его внутренних элементов.
    const { component, elements } = await this._getComponent(layout)

    // Определяем область где будет располагаться разметка страницы
    this._pageElement = elements.page

    // Получаем корневой элемент в который рендерится весь сайт
    const root = document.querySelector(this.root)

    // Очищаем старое содержимое
    root.innerHTML = ''

    // Рендерим новое
    root.insertAdjacentElement('afterbegin', component)
  }

  /**
   * Рендер страницы
   *
   * @param component
   * @returns {Promise&lt;void&gt;}
   * @protected
   */
  _renderPage = async ({ component }) =&gt; {
    // Получаем корневой элемент в который рендерится весь сайт
    let root = document.querySelector(this._root)

    // Если у страницы был найден шаблон, то рендерить нужно только саму страницу,
    // так как шаблон уже добавлен на страницу сайта
    if (this._pageElement) {
      root = this._pageElement
    }

    // Очищаем старое содержимое
    root.innerHTML = ''

    // Рендерим новое
    root.insertAdjacentElement('afterbegin', component)

    // Очищаем область где будет располагаться разметка страницы
    this._pageElement = null
  }

  /**
   * Базовая страница 404
   *
   * @protected
   */
  _page404() {
    document.querySelector(this._root).innerHTML = 'Страница 404 не найдена'
  }

  /**
   * Получение текущей ссылки
   *
   * @returns {string}
   */
  getUri() {
    // Ссылка будет форматирована согласно выбранному режиму
    if (this._history === HISTORY_TYPE_ENUM.STATE) {
      return this._strippedPath()
    }

    return this._strippedHashPath()
  }

  /**
   * Получение параметров из ссылки
   *
   * Пример: /foo/1/bar/2 =&gt; { foo: 1, bar: 2 }
   *
   * @returns {{}}
   * @protected
   */
  _getParams() {
    return this.getUri()
      .slice(1)
      .split('/')
      .reduce((acc, item, index, array) =&gt; {
        if (index % 2 === 0 &amp;&amp; array[index + 1]) {
          acc[item] = array[index + 1]
        }

        return acc
      }, {})
  }

  /**
   * Поиск текущего роута
   *
   * @param route
   * @returns {*}
   * @protected
   */
  _findRoute(route) {
    return this._routes.find(item =&gt; {
      const regex = new RegExp(`^${item.path}$`)

      return route.match(regex)
    })
  }

  /**
   * Получение шаблона или страницы
   *
   * @param component - import('@/foo/bar')
   * @param params - { foo: 1, bar: 2 }
   * @returns {Promise&lt;*&gt;}
   * @protected
   */
  async _getComponent(component, params = {}) {
    let Component = component

    // Так как компонент страницы может быть передан как динамически так и нет,
    // то мы должны проверить при динамическом импорте мы получим Promise
    if (Component instanceof Promise) {
      const module = await Component

      Component = module.default
    }

    return new Component({
      ...params,
      router: this,
    })
  }
}</code></pre>
  </div>
</div>

<h2 id="app"><span class="attention">Класс</span> App</h2>

<p>Класс <strong>App</strong> будет исполнять роль инициализации приложения. Он будет получать созданный роут и вызывать его метод на отображение страницы. Прежде всего откроем файл <strong>./src/main.js</strong> и добавим в него к уже имеющемуся коду следующее содержимое:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import router from '@/routers' // роутер приложения
import App from '@/core/App' // для инициализации приложения

import '@/assets/scss/global.scss' // глобальные стили приложения

const app = new App(router) // создаем приложение

app.run() // инициализируем приложение</code></pre>
  </div>
</div>

<p>Входной файл приложения получился у нас довольно компактным и простым. Теперь приступим непосредственно к описанию самого класса <strong>App</strong>. Для этого каталоге <strong>./src/core</strong> создадим файл <strong>App.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">/**
 * Инициализация приложения
 *
 */
export default class App {
  /**
   * Объект класса Router
   *
   * @type {{}}
   */
  #router = {}

  /**
   * Создание приложения
   *
   * @param router
   */
  constructor(router) {
    // Получаем объект класса Router
    this.#router = router
  }

  /**
   * Инициализация приложения
   *
   * @param selector
   */
  run(selector = '#app') {
    // Определяем основной селектор приложения
    // в котором будет производиться отрисовка сайта
    this.#router['root'] = selector

    // Рендерим страницу сайта
    this._render()

    // При изменении ссылки заново рендерим страницу
    window.addEventListener(this.#router.history, () =&gt; this._render())
  }

  /**
   * Рендер страницы сайта
   *
   * @protected
   */
  _render() {
    this.#router.render()
  }
}</code></pre>
  </div>
</div>

<p>Мы полностью закончили с классом <strong>App</strong> и с входным файлом <strong>main.js</strong>.</p>

<h2 id="base-component"><span class="attention">Класс</span> BaseComponent</h2>

<p>Мы создали прочную основу для нашего фреймворка в роли классов <strong>App</strong> и <strong>Router</strong>, но сами по себе они ни чего не дадут без механизма работы с <strong>DOM</strong> деревом. Именно этим мы сейчас займемся, создадим класс <strong>BaseComponent</strong> который будет служить родительским классом для всех наших страниц и компонентов приложения.</p>

<p>В каталоге <strong>./src/core</strong> создадим файл <strong>BaseComponent.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">export default class BaseComponent {
  /**
   * Node элемент самого компонента
   *
   * @type {null}
   * @protected
   */
  _component = null

  /**
   * Вложенные в компонент элементы верстки
   *
   * С которыми в процессе необходимо будет взаимодействовать.
   *
   * @type {{}}
   * @protected
   */
  _elements = {}

  /**
   * Вложенные в компонент другие компоненты
   *
   * @type {{}}
   * @protected
   */
  _components = {}

  /**
   * Для отмены прослушки событий
   *
   * @type {AbortController}
   * @protected
   */
  _abortController = new AbortController()

  /**
   * Абстрактный класс
   */
  constructor() {
    if (this.constructor.name === 'BaseComponent') {
      throw new TypeError('Абстрактный класс!')
    }
  }

  /**
   * Получение разметки компонента
   *
   * @returns {string}
   * @protected
   */
  get _template() {
    return ''
  }

  /**
   * Получение компонента
   *
   * @returns {null}
   */
  get component() {
    return this._component
  }

  /**
   * Получение вложенных в компонент элементов верстки
   *
   * @returns {{}}
   */
  get elements() {
    return this._elements
  }

  /**
   * Установка вложенных компонентов
   *
   * @param components
   * @protected
   */
  _setComponents(components) {
    this._components = components
  }

  /**
   * Переотрисовка вложенных компонентов
   *
   * @param components
   * @protected
   */
  _reloadComponents(components) {
    this._setComponents(components)
    this._initComponents()
  }

  /**
   * Инициализация компонента
   *
   * @protected
   */
  _init() {
    this._beforeInit().then()
    this._initComponent()
    this._initElements()
    this._initComponents()
    this._initListeners()
    this._afterInit().then()
  }

  /**
   * Пользовательские действия, происходящие до инициализации компонента
   *
   * @returns {Promise&lt;void&gt;}
   * @protected
   */
  async _beforeInit() {
    // Абстрактный метод!
    // await this._loadData()
    // await this._updateData()
  }

  /**
   * Пользовательские действия, происходящие после инициализации компонента
   *
   * @returns {Promise&lt;void&gt;}
   * @protected
   */
  async _afterInit() {
    // Абстрактный метод!
    // await this._loadData()
    // await this._updateData()
  }

  /**
   * Загрузка данных, например по api
   *
   * @protected
   */
  _loadData() {
    // Абстрактный метод!
  }

  /**
   * Обновление данных
   *
   * @protected
   */
  _updateData() {
    // Абстрактный метод!
  }

  /**
   * Создание ноды компонента
   *
   * @protected
   */
  _initComponent() {
    // Создаем элемент обертки
    const wrapper = document.createElement('div')

    // Помещаем внутрь обертки разметку html компонента
    wrapper.innerHTML = this._template

    // Получаем разметку компонента в виде Node
    this._component = wrapper.firstElementChild || wrapper
  }

  /**
   * Получение вложенных элементов в компоненте
   *
   * @param component
   * @protected
   */
  _initElements(component = this._component) {
    // Находим все элементы внутри компонента имеющие атрибут data-el
    const list = component.querySelectorAll('[data-el]')

    // Перебираем каждый вложенный элемент с атрибутом data-el
    list.forEach(item =&gt; {
      // Получаем значение атрибута data-el
      const name = item.dataset.el

      // Сохраняем Node каждого элемента
      this._elements[name] = item
    })
  }

  /**
   * Инициализация вложенных компонентов
   *
   * @protected
   */
  _initComponents() {
    // Проходимся по каждому ключу объекта _components
    for (const componentName of Object.keys(this._components)) {
      // Ключи подключаемых компонентов должны совпадать с названием
      // атрибута data-el у вложенных в родительский компонент элемента,
      // находим такой элемент, на его место будет подставляться, вложенный компонент.
      let root = this._elements[componentName]

      // Вложенный компонент можно передать двумя способами:
      // _setComponents({ nameComponent: new SomeComponent() })
      // _setComponents({ nameComponent: SomeComponent })
      // здесь идет определение того каким образом был передан вложенный компонент
      // и на основе этого идет получение свойства _component, который в свою очередь хранит
      // Node элемент компонента
      const { component } =
        typeof this._components[componentName] === 'object' &amp;&amp;
        !Array.isArray(this._components[componentName])
          ? this._components[componentName]
          : new this._components[componentName]()

      // Если элементы найдены, то рендерим компонент
      if (root &amp;&amp; component) {
        // Получаем data-el
        component.dataset.el = root.dataset.el

        // Переопределяем внутренний элемент
        this._elements[root.dataset.el] = component

        // Рендерим компонент
        root.insertAdjacentElement('beforebegin', component)
        root.remove()
        root = null

        // Получаем вложенные элементы в компоненте
        this._initElements(component)
      }
    }
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {
    // Абстрактный метод!
  }

  /**
   * Обновление содержимого компонента
   *
   * @param data
   */
  update(data = {}) {
    // Перебираем все необходимые вложенные элементы
    // и изменяем их внутреннее содержимое
    for (const [key, value] of Object.entries(data)) {
      if (this._elements[key]) {
        this._elements[key].innerHTML = value
      }
    }
  }

  /**
   * Полное удаление компонента
   */
  destroy() {
    this._remove()
    this._removeListeners()
  }

  /**
   * Удаление компонента
   *
   * @protected
   */
  _remove() {
    // this._component?.remove()
    this._component.innerHTML = ''
    this._elements = {}
  }

  /**
   * Удаление прослушек событий
   *
   * @protected
   */
  _removeListeners() {
    this._abortController.abort()
  }
}</code></pre>
  </div>
</div>

<p>Теперь можно непосредственно приступить к созданию страниц приложения.</p>

<h2 id="base-page"><span class="attention">Класс</span> BasePage</h2>

<p>У всех страниц есть общие повторяющиеся параметры поэтому создадим родительский класс <strong>BasePage</strong> для всех страниц. В каталоге <strong>./src/core</strong> создайте файл <strong>BasePage.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BaseComponent from '@/core/BaseComponent' // Базовый компонент

/**
 * Базовая страница
 */
export default class BasePage extends BaseComponent {
  /**
   * Шаблон страницы
   *
   * @type {Promise&lt;{readonly default?: *}&gt;}
   * @protected
   */
  _layout = import('@/layouts/MainLayout')

  /**
   * Заголовок страницы
   *
   * @type {string}
   * @protected
   */
  _title = 'JavaScript framework'

  /**
   * Создание страницы
   */
  constructor() {
    super()

    document.title = 'Главая страница'
  }

  /**
   * Получение шаблона страницы
   *
   * @returns {Promise&lt;{readonly default?: *}&gt;}
   */
  get layout() {
    return this._layout
  }
}</code></pre>
  </div>
</div>

<h2 id="main-layout"><span class="attention">Класс</span> MainLayout</h2>

<p>При создании класса <strong>BaseComponent</strong> шаблоном по умолчанию для всех страниц мы определили <strong>MainLayout</strong>, в этом разделе давайте займемся его созданием. Создадим каталог <strong>./src/layouts</strong>, который будет хранить различные шаблоны приложения и внутри данного каталога создадим каталог <strong>MainLayout</strong> с файлом внутри <strong>index.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BaseComponent from '@/core/BaseComponent' // базовый компонент

// Стили шаблона
import '@/layouts/MainLayout/main-layout.scss'

/**
 * Основной шаблон
 */
export default class MainLayout extends BaseComponent {
  /**
   * Создание шаблона
   */
  constructor() {
    super()

    // Инициализируем шаблон
    this._init()
  }

  /**
   * Разметка шаблона
   *
   * @returns {string}
     * @protected
     */
  get _template() {
      return `
        &lt;div class="main-layout"&gt;
          &lt;header class="main-header"&gt;
            &lt;div class="container"&gt;Шапка сайта&lt;/div&gt;
          &lt;/header&gt;

          &lt;main data-el="page"&gt;&lt;!-- PageComponent --&gt;&lt;/main&gt;

          &lt;footer class="main-footer"&gt;
            &lt;div class="container"&gt;Copyright 2023&lt;/div&gt;
          &lt;/footer&gt;
        &lt;/div&gt;
      `
  }
}</code></pre>
  </div>
</div>

<p>Сразу создадим файл <strong>main-layout.scss</strong> внутри каталога с нашим шаблоном. В нем будут стили текущего шаблона.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">SCSS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="scss">.main-layout {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.main-header {
  margin-bottom: 20px;

  color: #fff;

  background-color: #000;
}

.main-layout main {
  flex-grow: 1;
}

.main-footer {
  margin-top: 20px;
  padding: 20px 0;

  background-color: #c2c2c2;
}</code></pre>
  </div>
</div>

<p>Не обращайте внимание, что у нас нет разделения на отдельные стили для шапки, подвала и контента, это сделано, чтобы упростить пример. В идеале конечно хорошо было бы вынести шапку и подвал в отдельные компоненты и подключить их в шаблоне. О том как внедрять компоненты на страницу и друг в друга будет рассмотрено в следующем разделе, когда мы приступим к созданию самой страницы.</p>

<p>А сейчас рассмотрим основную логику работы шаблона. У нас имеется атрибут <strong>data-el=”page”</strong> он является служебным. В него всегда будет рендериться текущая страница, которая определена в файле <strong>./src/routers/index.js</strong>. При создании шаблона нужно всегда указывать <strong>data-el=”page”</strong>.</p>

<h2 id="pages"><span class="attention">Страницы</span> HomePage, AboutPage, ErrorPage</h2>

<p>В разделе <a href="/blog/2023-09-18-sozdaem-svoj-framework-na-nativnom-javascript-ispolzuya-webpack-frontend.html#router" target="_blank">класс Router</a> при создании маршрутов были описаны страницы <strong>HomePage</strong>, <strong>AboutPage</strong> и <strong>ErrorPage</strong> давайте их создадим. Для этого создадим каталог <strong>./src/pages</strong> и внутри него файлы <strong>HomePage.js</strong>, <strong>AboutPage.js</strong> и <strong>ErrorPage.js</strong>.</p>

<p>Если нужно иметь для страницы свои стили, то можно по аналогии с <strong>MainLayout</strong> создать каталог с названием страницы, например <strong>HomePage</strong> и внутри него создать файл <strong>index.js</strong> который будет содержать код логики страницы. И рядом с этим файлом создать файл со стилями, например <strong>home-page.scss</strong>. Затем подключить его в файле <strong>HomePage/index.js</strong> следующим образом: <strong>@import ‘@/pages/HomePage/home-page.scss’</strong>.</p>

<h3 id="страница-homepagejs">Страница HomePage.js</h3>

<p>Внутри главной страницы подключаем компонент <strong>LogoComponent</strong>, пока он еще не создан к нему приступим немного позже.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BasePage from '@/core/BasePage' // базовая страница
import LogoComponent from '@/components/LogoComponent' // логотип

// Подключаемые компоненты
const components = {
  logo: new LogoComponent({ title: 'JavaScript Framework' }),
}

/**
 * Главная страница
 */
export default class HomePage extends BasePage {
  /**
   * Создание главной страницы
   */
  constructor() {
    super()

    document.title = `Главная страница - ${this._title}`

    // Подключение компонентов
    this._setComponents(components)

    // Инициализация главной страницы
    this._init()
  }

  /**
   * Разметка страницы
   *
   * @returns {string}
   * @protected
   */
  get _template() {
    return `
      &lt;div class="home-page"&gt;
        &lt;div class="container"&gt;
          &lt;div data-el="logo"&gt;&lt;!-- LogoComponent --&gt;&lt;/div&gt;

          &lt;button type="button" data-el="btn"&gt;Кнопка&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {
    this._elements['btn'].addEventListener('click', () =&gt; console.log('Клик по кнопке'))
  }
}</code></pre>
  </div>
</div>

<p>В разметке страницы или другого компонента через атрибут <strong>data-el</strong> определяются области, в которые мы хотим отрисовать другие компоненты. В коде есть объект <strong>components</strong> хранящий различные компоненты. Важно чтобы ключи этого объекта совпадали с названием атрибута <strong>data-el</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">// Значение logo подставится на место data-el="logo"
const components = {
  logo: new LogoComponent({ title: 'JavaScript Framework' }),
}

...

// Значение components.logo подставится на место data-el="logo"
&lt;div data-el="logo"&gt;&lt;!-- LogoComponent --&gt;&lt;/div&gt;</code></pre>
  </div>
</div>

<p>Так же доступ к элементам с атрибутом <strong>data-el</strong> можно получить через свойство <strong>this._elements[‘сюда указываем имя нужного атрибута’]</strong>, например:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">...

&lt;button type="button" data-el="btn"&gt;Кнопка&lt;/button&gt;

...</code></pre>
  </div>
</div>

<p>Далее в коде мы можем обратиться к этому элементу например повесив на него событие:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">...

_initListeners() {
  this._elements['btn'].addEventListener('click', () =&gt; console.log('Клик по кнопке'))
}</code></pre>
  </div>
</div>

<p>Если нужно по новой рендерить компонент, то можно вызвать метод <strong>_reloadComponents</strong>, например:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">components.logo = new LogoComponent({ title: 'JavaScript Framework 2.0' })

this._reloadComponents(components)</code></pre>
  </div>
</div>

<p>Основные механики заложенные в наш фреймворк по работе с компонентами мы разобрали, напоминаю что данная логика прописана в файле <strong>./src/core/BaseComponent.js</strong>.</p>

<h3 id="страница-aboutpagejs">Страница AboutPage.js</h3>

<p>Страницы <strong>AboutPage</strong> будет носить чисто информативный характер, для того чтобы мы могли протестировать переключение между страницами без перезагрузки страницы.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BasePage from '@/core/BasePage' // базовая страница

/**
 * Страница о нас
 */
export default class AboutPage extends BasePage {
  /**
   * Создание страницы о нас
   */
  constructor() {
    super()

    document.title = `О нас - ${this._title}`

    // Инициализация страницы о нас
    this._init()
  }

  /**
   * Разметка страницы
   *
   * @returns {string}
     * @protected
     */
  get _template() {
      return `
        &lt;div&gt;
          Создание самописного framework на нативном JavaScript с использованием Webpack.
        &lt;/div&gt;
      `
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {}
}</code></pre>
  </div>
</div>

<h3 id="страница-errorpagejs">Страница ErrorPage.js</h3>

<p>Страницы <strong>ErrorPage</strong> будет отображаться при переходе по не зарегистрированному маршруту.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BasePage from '@/core/BasePage' // базовая страница

/**
 * Страница 404
 */
export default class ErrorPage extends BasePage {
  /**
   * Создание страницы
   */
  constructor() {
    super()

    document.title = `Страница 404 - ${this._title}`

    // Инициализация страницы
    this._init()
  }

  /**
   * Разметка страницы
   *
   * @returns {string}
     * @protected
     */
  get _template() {
      return `
        &lt;div&gt;
          Страница не найдена 404.
        &lt;/div&gt;
      `
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {}
}</code></pre>
  </div>
</div>

<h2 id="logo-component"><span class="attention">Компонент</span> LogoComponent</h2>

<p>В предыдущем разделе мы создали страницу <strong>HomePage</strong>, где внедряли компонент <strong>LogoComponent</strong>. В этом разделе мы опишем его.</p>

<p>Создадим каталог <strong>./src/components/LogoComponent</strong> и внутри него файл <strong>index.js</strong> который будет содержать всю логику компонента. Так же рядом можно создать файл со стилями данного компонента, например <strong>logo.scss</strong>. Опишем наш компонент:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BaseComponent from '@/core/BaseComponent' // базовый компонент

import '@/components/LogoComponent/logo.scss'

/**
 * Логотип
 */
export default class LogoComponent extends BaseComponent {
  /**
   * Создание главной страницы
   */
  constructor({ title = '' } = {}) {
    super()

    this._title = title

    // Инициализация компонента лого
    this._init()
  }

  /**
   * Разметка компонента
   *
   * @returns {string}
   * @protected
   */
  get _template() {
    return `
      &lt;div&gt;
        &lt;img src="logo.svg" width="150" height="80" alt="${this._title}"&gt;
      &lt;/div&gt;
    `
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {}
}</code></pre>
  </div>
</div>

<p>Главным отличием компонента от страницы является, то что он наследуется не от <strong>BasePage</strong>, а напрямую от <strong>BaseComponent</strong>. В остальном он так же может внедрять внутрь себя другие компоненты, как это было показано на примере <strong>HomePage</strong>.</p>

<p>В конструктор компонента мы можем передавать какие-то специфичные для этого компонента параметры и затем в коде обращаться к ним, как это сделано на примере значения <strong>title</strong>.</p>

<p>Теперь в <strong>HomePage</strong> на место <strong>&lt;div data-el=”logo”&gt;&lt;!– LogoComponent –&gt;&lt;/div&gt;</strong> подставится содержимое <strong>get _template()</strong> компонента <strong>LogoComponent</strong>.</p>

<h2 id="link-component"><span class="attention">Компонент</span> Link</h2>

<p>Компонент <strong>Link</strong> нужен для того, что бы реализовать переключение между страницами без перезагрузки страницы. Добавим данный компонент для этого создадим файл <strong>./src/core/Link.js</strong>. Опишем его код:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import Router from '@/core/Router/Router' // роутер
import BaseComponent from '@/core/BaseComponent' // базовый компонент

/**
 * Ссылка на внутренние страницы приложения
 */
export default class Link extends BaseComponent {
  /**
   * Список всех проинициализированных ссылок
   *
   * @type {[]}
   * @protected
   */
  static _links = []

  /**
   * Создание ссылки
   *
   * @param url
   * @param html
   * @param attributes
   * @param activeClass
   */
  constructor({
    url = '',
    html = '',
    attributes = {},
    activeClass = 'active',
  } = {}) {
    super()

    this._router = Router.instance // роутер

    this._url = this._correctUrl(url) // ссылка
    this._html = html // содержимое ссылки
    this._attributes = attributes // атрибуты ссылки
    this._activeClass = activeClass // класс активной ссылки

    this._init() // инициализация компонента Link
  }

  /**
   * Получение роутера
   *
   * @returns {Router.instance}
   */
  get router() {
    return this._router
  }

  /**
   * Получение активного класса
   *
   * @returns {string}
   */
  get activeClass() {
    return this._activeClass
  }

  /**
   * Исправление ссылки для ссылки вида хэш
   *
   * @param url
   * @returns {*}
   * @protected
   */
  _correctUrl(url) {
    if (this._router.history === Router.createWebHashHistory()) {
      url = url.replace(/^\//, '/#/') // меняет / -&gt; /#/
    }

    return url
  }

  /**
   * Инициализация компонента
   *
   * @protected
   */
  _initComponent() {
    // Создаем элемент ссылка
    this._component = document.createElement('a')

    // Если урл ссылки соответствует урл в браузере делаем ссылку активной
    if (this._url === this._router.getUri()) {
      this._component.classList.add(this._activeClass)
    }

    // Добавляем урл в ссылку
    this._component.setAttribute('href', this._url)

    // Добавляем содержимое в ссылку
    this._component.innerHTML = this._html

    // Добавляем аттрибуты ссылки
    Object.entries(this._attributes).forEach(([prop, value]) =&gt; {
      this._component.setAttribute(prop, `${value}`)
    })

    // Аккумулируем все ссылки
    Link._links.push({
      link: this._component,
      activeClass: this._activeClass,
    })
  }

  /**
   * Прослушка событий
   *
   * @protected
   */
  _initListeners() {
    this._component.addEventListener('click', async evt =&gt; {
      // Отменяем стандартный переход по ссылки
      evt.preventDefault()

      // Получаем урл ссылки
      const path = evt.currentTarget.getAttribute('href')

      // Меняем урл в браузере на урл ссылки
      window.history.pushState(null, null, path)

      // Переключаем классы у активных ссылок
      this._toggleClass()

      // Рендарим страницу
      await this._router.render()
    })

    // Переключаем классы у активных ссылок при изменении страницы
    window.addEventListener(this._router.history, () =&gt; this._toggleClass(), {
      signal: this._abortController.signal,
    })
  }

  /**
   * Переключаем классы у активных ссылок
   *
   * @protected
   */
  _toggleClass() {
    Link._links.forEach(({ link, activeClass }) =&gt; {
      const linkUri = new URL(link.href).pathname

      if (linkUri === this._router.getUri()) {
        link.classList.add(activeClass)
      } else {
        link.classList.remove(activeClass)
      }
    })
  }
}</code></pre>
  </div>
</div>

<p>Теперь мы можем подключить компонент <strong>Link</strong> к примеру в <strong>MainLayout</strong>, например:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">...

const components = {
  homeLink: new Link({
    url: '/',
    html: 'Главная страница',
    attributes: { class: 'home' },
  }),

  aboutLink: new Link({
    url: '/about',
    html: 'О фреймворке',
    attributes: { class: 'framework' },
  }),
}

...

constructor() {
  super()

  // Установка компонентов
  this._setComponents(components)

  // Инициализируем шаблон
  this._init()
}

get _template() {
  return `
    &lt;div class="main-layout"&gt;
      &lt;header class="main-header"&gt;
        &lt;div class="container"&gt;
          &lt;div data-el="homeLink"&gt;&lt;!-- homeLink --&gt;&lt;/div&gt;
          &lt;div data-el="aboutLink"&gt;&lt;!-- aboutLink --&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/header&gt;

      &lt;main data-el="page"&gt;&lt;!-- PageComponent --&gt;&lt;/main&gt;

      &lt;footer class="main-footer"&gt;
        &lt;div class="container"&gt;Copyright 2023&lt;/div&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  `
}</code></pre>
  </div>
</div>

<h2 id="response"><span class="attention">Класс</span> Response</h2>

<p>Создадим простой аналог библиотеки <strong>axios</strong> для запросов данных у сервера по <strong>api</strong>. Для этого создадим файл <strong>./src/core/Response.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">/**
 * Запросы к серверу
 *
 * Вольная реализация axios.
 */
export default class Response {
  // Используется для создания объекта класса
  static _initialization = false

  // Опции запроса
  _options = {}

  // Базовый урл запроса
  _baseUrl = ''

  /**
   * Создание запроса напрямую запрещен
   */
  constructor() {
    if (!Response._initialization) {
      throw new TypeError('Нельзя напрямую создать экземпляр данного класса')
    }
  }

  /**
   * Создание запроса
   *
   * @param options
   * @returns {Response}
   */
  static create(options = {}) {
    // Создаем объект класса
    Response._initialization = true
    const response = new Response()
    Response._initialization = false

    // Получаем базовый урл
    response._baseUrl = options.baseUrl ?? ''

    // Удаляем базовый урл из опциональных параметров
    delete options.baseUrl

    // Получаем опциональные параметры
    response._options = options

    return response
  }

  /**
   * Запрос на сервер
   *
   * @param url
   * @param options
   * @returns {Promise&lt;any&gt;}
   * @private
   */
  _response = async (url, options = {}) =&gt; {
    try {
      const response = await fetch(url, options)

      return await response.json()
    } catch (e) {
      // eslint-disable-next-line
      if (process.env.NODE_ENV === 'development') console.log(e.message)
      throw e
    }
  }

  /**
   * Получение данных методом GET
   *
   * @param url
   * @returns {Promise&lt;*&gt;}
   */
  get(url = '') {
    url = new URL(url, this._baseUrl)

    return this._response(url.href, this._options)
  }

  /**
   * Получение данных методом POST
   *
   * @param url
   * @param data
   * @returns {Promise&lt;*&gt;}
   */
  post(url = '', data = {}) {
    url = new URL(url, this._baseUrl)

    this._options = {
      ...this._options,
      method: 'post',
      body: data,
    }

    return this._response(url.href, this._options)
  }
}</code></pre>
  </div>
</div>

<h3 id="productservicejs">ProductService.js</h3>

<p>Теперь создадим <strong>api</strong> сервис который используя созданный класс <strong>Response</strong> будет позволять получать данные с удаленного сервера.</p>

<p>Для этого создадим файл <strong>/src/services/ProductService.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import Response from '@/core/Response' // подобие axios

// Подготовительные POST запросы
const apiClientPost = Response.create({
  baseUrl: process.env.API_URL, // смотреть файл development.env или production.env
  credentials: 'omit',
  headers: {
    'Content-Type': 'application/json; charset=UTF-8',
  },
})

// Подготовительные GET запросы
const apiClientGet = Response.create({
  baseUrl: process.env.API_URL, // смотреть файл development.env или production.env
  credentials: 'omit',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
})

export default {
  /**
   * Добавление продукта
   *
   * @param data
   * @returns {*}
   */
  addProducts(data) {
    return apiClientPost.post('/products/add', data)
  },

  /**
   * Получение продуктов
   *
   * @returns {*}
   */
  loadProducts() {
    return apiClientGet.get('/products')
  },
}</code></pre>
  </div>
</div>

<p>Далее мы можем получить данные с сервера например на странице <strong>HomePage</strong>:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import ProductService from '@/services/ProductService'

const { addProducts, loadProducts } = ProductService

const products = await loadProducts()
const res = await addProducts(JSON.stringify({ name: 'Product new', type: 'discount' }))</code></pre>
  </div>
</div>

<p>Это примерный псевдо код как можно воспользоваться созданным сервисом для общего понимания принципа.</p>

<p>Мы могли без проблем напрямую через класс <strong>Response</strong> обратиться к <strong>api</strong> серверу, но тогда бы у нас обращение к серверу было бы разбросанно по всему коду нашего проекта. Прелесть создания сервисов в том, что мы собираем подключение к серверу в одном месте и потом в нужных участках кода обращаемся к нему. И если в дальнейшем понадобится изменить какие-то параметры подключения мы это сделаем в одном месте.</p>

<h2 id="store"><span class="attention">Класс</span> Store</h2>

<p>Создадим простой аналог библиотеки <strong>Redux</strong> для сохранения состояний приложения. Для этого добавим файл <strong>./src/core/Store.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">/**
 * Менеджер состояний
 *
 * Вольная реализация Redux.
 */
export default class Store {
  /**
   * Редьюсеры
   *
   * @type {[]}
   * @protected
   */
  _reducers = []

  /**
   * Состояния
   *
   * @type {{}}
   * @protected
   */
  _state = {}

  /**
   * События
   *
   * @type {{}}
   * @protected
   */
  _listeners = {}

  /**
   * Создание хранилища
   *
   * @param reducers
   * @param initState
   */
  constructor(reducers = [], initState = {}) {
    this._reducers = reducers
    this._state = initState
  }

  /**
   * Получить состояние
   *
   * @param name
   * @returns {{}|*}
   */
  getState(name = '') {
    if (this._state[name]) {
      return this._state[name]
    }

    return this._state
  }

  /**
   * Установить состояние
   *
   * @param newState
   * @protected
   */
  _setState(newState) {
    this._state = newState
  }

  /**
   * Подписки на события
   *
   * @param name
   * @param callback
   * @returns {(function(): void)|*}
   */
  subscribe(name, callback) {
    if (!this._listeners[name]) {
      this._listeners[name] = []
    }

    this._listeners[name].push(callback)

    return () =&gt; {
      this._listeners = this._listeners[name].filter(
        listener =&gt; listener !== callback,
      )
    }
  }

  /**
   * Вызов события
   *
   * @param action
   */
  dispatch(action) {
    for (const reducer of this._reducers) {
      const previousState = this.getState()
      const newState = reducer(previousState, action)

      if (newState) {
        this._setState(newState)

        const listeners = this._listeners[action.type]

        if (listeners) {
          const currentState = this.getState()

          for (const listener of listeners) {
            listener(currentState)
          }
        }
      }
    }
  }
}</code></pre>
  </div>
</div>

<h3 id="bidsreducer">bidsReducer</h3>

<p>Пример того как мог бы выглядеть <strong>reducer</strong>. Создайте файл <strong>./src/reducers/bidsReducer.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import BidService from '@/services/BidService' // запросы заявок

const { loadBids } = BidService // получение заявок

export const REFRESH_BIDS = 'REFRESH_BIDS' // для обновления заявок

/**
 * Обновление заявок
 *
 * @param bids
 * @returns {{bids, type: string}}
 */
export const refreshBids = bids =&gt; ({
  type: REFRESH_BIDS,
  bids,
})

/**
 * Получение заявок
 *
 * @type {*}
 */
const bids = await loadBids()

/**
 * Состояние заявок
 *
 * @type {{bids: *, countBids}}
 */
export const bidsState = {
  bids,
  countBids: bids.length,
}

/**
 * Reducer заявок
 *
 * @param previousState
 * @param action
 * @returns {*|null}
 */
export const bidsReducer = (previousState, action) =&gt; {
  switch (action.type) {
    case REFRESH_BIDS:
      previousState.bids = action.bids

      return {
        ...previousState,
      }

    default:
      return null
  }
}

export default bidsReducer</code></pre>
  </div>
</div>

<h3 id="создание-менеджера-состояния">Создание менеджера состояния</h3>

<p>Теперь когда у нас есть менеджер состояний и редьюсер добавим наше хранилище. Для этого создадим файл <strong>./src/store/index.js</strong> со следующим содержимым:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import Store from '@/core/Store' // хранилище типа Redux
import { bidsReducer, bidsState } from '@/reducers/bidsReducer' // reducer для заявок

// Объединяем все reducer
const reducers = [bidsReducer]

// Объединяем все состояния
const initState = {
  ...bidsState,
}

// Регистрация хранилища состояний
const store = new Store(reducers, initState)
const storeKey = Symbol.for('storeKey')

// Не обязательно использовать globalThis можно просто вернуть store
// globalThis в дальнейшем может пригодиться для отладки
globalThis[storeKey] = store

export default globalThis[storeKey]</code></pre>
  </div>
</div>

<h3 id="пример-использования-менеджера-состояния">Пример использования менеджера состояния</h3>

<p>Где-то в коде страницы или компонента мы можем подписаться на событие <strong>REFRESH_BIDS</strong>.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">import store from '@/store'

store.subscribe(REFRESH_BIDS, () =&gt; {
  // Здесь происходит какая то логика.
  // Данный колбэк сработает при вызове редьюсера у которого параметр type будет равен REFRESH_BIDS.
})</code></pre>
  </div>
</div>

<p>И затем к примеру в другом компоненте вызвать действие редьюсера:</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const data = [1,2,3,4,5]

store.dispatch(refreshBids(data))</code></pre>
  </div>
</div>

<h2 id="end"><span class="attention">Итоги</span> создания фреймворка</h2>

<p>Мы проделали большую работу в создании собственного фреймворка. Многие вещи скорей всего до конца не раскрыты ввиду того, что требуется большое количество времени чтобы все более подробно и детально расписать.</p>

<p>Насколько мог я, прокомментировал каждую строчку кода, и надеюсь это поможет хоть немного при изучении данного материала понять логику и суть проделанной работы.</p>

<p>Ну а пока можете ознакомиться с <a href="https://github.com/eliofery/javascript-framework-shop" target="_blank" rel="nofollow">готовым сайтом</a> написанном мной на этом фреймворке. <a href="https://github.com/eliofery/javascript-framework-shop" target="_blank" rel="nofollow">Исходники готового сайта</a> так же будут доступны в репозитории.</p>

<p>Успешного изучения <strong>JavaScript</strong>.</p>]]></content><author><name></name></author><category term="frontend" /><category term="javascript" /><category term="webpack" /><category term="linter" /><category term="redux" /><summary type="html"><![CDATA[В этой статье речь пойдет о написании своего велосипеда в виде JavaScript framework. Затронем такие технологии как Webpack, Linter, Redux.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Структура данных связанный список</title><link href="http://localhost:4000/blog/2023-09-16-struktura-dannyh-spisok-dsa.html" rel="alternate" type="text/html" title="Структура данных связанный список" /><published>2023-09-16T09:16:00+06:00</published><updated>2023-09-16T09:16:00+06:00</updated><id>http://localhost:4000/blog/struktura-dannyh-spisok</id><content type="html" xml:base="http://localhost:4000/blog/2023-09-16-struktura-dannyh-spisok-dsa.html"><![CDATA[<p>Рассмотрим структуру данных список, научимся добавлять, удалять, находить, выводить элементы списка.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#node">Узел списка (LinkedListNode)</a></li>
  <li><a href="#list">Список (LinkedList)</a></li>
  <li><a href="#example">Пример использования</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Связанный список (List) — представляет собой структуру данных, где элементы хранятся последовательно. Каждый элемент содержит своё значение и ссылку на следующий элемент в списке. Ссылка представляет собой указатель на другой узел или значение null, если следующего элемента нет.</p>

<h2 id="node"><span class="attention">Узел</span> списка (LinkedListNode)</h2>

<p>Узел списка представляет собой элемент в связанном списке. Связанный список - это структура данных, которая состоит из узлов, каждый из которых содержит две части: данные (обычно это какое-то значение) и ссылку (или указатель) на следующий узел в списке.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">class LinkedListNode {
  constructor(value, next = null) {
    this.value = value;
    this.next = next;
  }

  toString(callback) {
    return callback ? callback(this.value) : `${this.value}`;
  }
}</code></pre>
  </div>
</div>

<h2 id="list"><span class="attention">Список</span> (LinkedList)</h2>

<p>Список это структура данных, используемая для организации коллекции элементов, в которой каждый элемент, называемый узлом, состоит из двух частей: данных и ссылки (или указателя) на следующий элемент в списке. Это отличается от массива, где элементы хранятся в последовательности и имеют индексы для доступа к ним.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  prepend(value) {
    // Создаём новый узел, который будет новым head,
    // при создании передаем второй аргумент, который указывает
    // что его "next" будет текущий head,
    // так как новый узел будет стоять перед текущем head.
    const newNode = new LinkedListNode(value, this.head);

    // Переназначаем head на новый узел
    this.head = newNode;

    // Если ещё нет tail, делаем новый узел tail.
    if (!this.tail) {
      this.tail = newNode;
    }

    // Возвращаем весь список.
    return this;
  }

  append(value) {
    // Создаём новый узел.
    const newNode = new LinkedListNode(value);

    // Если нет head или tail, делаем новым узлом head и tail.
    if (!this.head || !this.tail) {
      this.head = newNode;
      this.tail = newNode;

      return this;
    }

    // Присоединяем новый узел к концу связного списка.
    // Берём последний узел и указываем, что его next будет новым узлом.
    this.tail.next = newNode;

    // Переназначаем tail на новый узел.
    this.tail = newNode;

    return this;
  }

  delete(value) {
    // Если нет head значит список пуст.
    if (!this.head) {
      return null;
    }

    let deletedNode = null;

    // Если head должен быть удален, то делаем следующий узел новым head.
    while (this.head &amp;&amp; this.head.value === value) {
      deletedNode = this.head;

      // Переназначаем следующий за head узел на новый head.
      this.head = this.head.next;
    }

    let currentNode = this.head;

    // Если следующий узел должен быть удален,
    // делаем узел через один, следующим для проверки.
    // Перебираем все узлы и удаляем их, если их значение равно указанному.
    if (currentNode !== null) {
      while (currentNode.next) {
        if (currentNode.next.value === value) {
          deletedNode = currentNode.next;
          // Перезаписываем, чтобы узел через один стал следующим узлом.
          currentNode.next = currentNode.next.next;
        } else {
          currentNode = currentNode.next;
        }
      }
    }

    // Проверяем, должен ли tail быть удален.
    // Так как, если в цикле мы удаляем последний узел,
    // то с предпоследнего узла убираем только ссылку на него.
    // Поэтому делаем проверку на его удаление с "tail".
    if (this.tail &amp;&amp; this.tail.value === value) {
      // в данном случае currentNode это или предпоследний узел или head.
      this.tail = currentNode;
    }

    return deletedNode;
  }

  find(value) {
    // Если нет head значит список пуст.
    if (!this.head) {
      return null;
    }

    let currentNode = this.head;

    // Перебираем все узлы в поиске значения.
    while (currentNode) {
      // Если указано значение, пробуем сравнить его по значению.
      if (value !== undefined &amp;&amp; currentNode.value === value) {
        return currentNode;
      }

      // Перематываем на один узел вперед.
      currentNode = currentNode.next;
    }

    return null;
  }


  deleteTail() {
    // Если нет tail, значит список пуст.

    if (!this.tail) {
      return null;
    }

    // Сохраняем значение последнего узла.
    const deletedTail = this.tail;

    // Если head и tail равны, значит в списке только один узел.
    if (this.head === this.tail) {
      this.head = null;
      this.tail = null;

      return deletedTail;
    }

    // Если в связном списке много узлов.
    // Перебираем все узлы и находим предпоследний узел,
    // убираем ссылку «next» на последний узел.
    let currentNode = this.head;
    while (currentNode.next) {
      // Если у следующего узла нет следующего узла,
      // значит текущий узел предпоследний.
      if (!currentNode.next.next) {
        // убираем ссылку «next» на последний узел.
        currentNode.next = null;
      } else {
        // Перематываем на один узел вперед.
        currentNode = currentNode.next;
      }
    }

    // В данном случае currentNode - это предпоследний узел или head,
    // который становится последним узлом.
    this.tail = currentNode;

    return deletedTail;
  }

  deleteHead() {
    // Если нет head значит список пуст.
    if (!this.head) {
      return null;
    }

    const deletedHead = this.head;

    // Если у head есть ссылка на следующий "next" узел
    // то делаем его новым head.
    if (this.head.next) {
      this.head = this.head.next;
    } else {
      // Если у head нет ссылки на следующий "next" узел
      // то мы удаляем последний узел.
      this.head = null;
      this.tail = null;
    }

    return deletedHead;
  }

  // Создаём новые узлы из массива и добавляем в конец списка.
  fromArray(values) {
    values.forEach(value =&gt; this.append(value));

    return this;
  }

  // Создаём массив из всех узлов
  toArray() {
    const nodes = [];

    let currentNode = this.head;

    // Перебираем все узлы и добавляем в массив.
    while (currentNode) {
      nodes.push(currentNode);
      currentNode = currentNode.next;
    }

    // Возвращаем массив из всех узлов.
    return nodes;
  }

  toString(callback) {
    // Сначала создаём массив из всех узлов.
    return this.toArray()
      // На каждом узле вызываем метод toString
      // что бы получить значение в виде строки.
      .map(node =&gt; node.toString(callback))
      // Вызываем метод toString на массиве строк.
      .toString();
  }

  // Обратный список
  reverse() {
    let currNode = this.head;
    let prevNode = null;
    let nextNode = null;

    // Перебираем все узлы.
    while (currNode) {
      // Сохраняем следующий узел.
      nextNode = currNode.next;

      // Меняем ссылку на следующий "next" узел текущего узла,
      // чтобы он ссылался на предыдущий узел.
      // Так как мы меняем их местами, нужно поменять и ссылки на узлы.
      // Изначально, первый узел не имеет предыдущего узла,
      // поэтому после перестановки его "next" станет "null".
      currNode.next = prevNode;

      // Перемещаем узлы prevNode и currNode на один шаг вперед.

      // Текущий узел делаем предыдущим.
      prevNode = currNode;

      // Следующий узел становится текущим.
      currNode = nextNode;
    }

    // Меняем head и tail местами.
    this.tail = this.head;

    // В данном случае prevNode это последний узел,
    // поэтому, после reverse, он становится первым.
    this.head = prevNode;

    // Возвращаем список.
    return this;
  }

  insertAfter(value, prevNode) {
    if (prevNode === null) {
      return this
    }

    const newNode = new LinkedListNode(value)

    newNode.next = prevNode.next
    prevNode.next = newNode

    if (newNode.next === null) {
      this.tail = newNode
    }

    return this
  }
}</code></pre>
  </div>
</div>

<h2 id="example"><span class="attention">Пример</span> использования</h2>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">let list = new LinkedList();

console.log(list);
// LinkedList { head: null, tail: null }

list.append("Щит");

console.log(list.find("Щит"));
// LinkedListNode { value: 'Щит', next: null }

list.append("Шлем");

console.log(list.find("Щит"));
// LinkedListNode {
//  value: 'Щит',
//  next: LinkedListNode { value: 'Шлем', next: null }
// }

list.append(1).append(2).append(3).append(4)

const find = list.find(3)

console.log(list.insertAfter(5, find))

/*
Вывод

{
  "head": {
    "value": 1,
    "next": {
      "value": 2,
      "next": {
        "value": 3,
        "next": {
          "value": 5,
          "next": {
            "value": 4,
            "next": null
          }
        }
      }
    }
  },
  "tail": {
    "value": 4,
    "next": null
  }
}
*/</code></pre>
  </div>
</div>]]></content><author><name></name></author><category term="dsa" /><category term="список" /><summary type="html"><![CDATA[Рассмотрим структуру данных список, научимся добавлять, удалять, находить, выводить элементы списка.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Решение задачек через бинарный поиск</title><link href="http://localhost:4000/blog/2023-09-14-reshenie-zadachek-cherez-binarnyj-poisk-dsa.html" rel="alternate" type="text/html" title="Решение задачек через бинарный поиск" /><published>2023-09-14T09:16:00+06:00</published><updated>2023-09-14T09:16:00+06:00</updated><id>http://localhost:4000/blog/reshenie-zadachek-cherez-binarnyj-poisk</id><content type="html" xml:base="http://localhost:4000/blog/2023-09-14-reshenie-zadachek-cherez-binarnyj-poisk-dsa.html"><![CDATA[<p>Рассмотрим решение типовых задачек на бинарный поиск.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#search-el">Найти элемент в отсортированном массиве</a></li>
  <li><a href="#low-bound">Нахождение нижней границы</a></li>
  <li><a href="#high-bound">Нахождение верхней границы</a></li>
  <li><a href="#insert-position">Поиск позиции для вставки</a></li>
  <li><a href="#floor-ceil">Поиск нижней и верхней позиции</a></li>
  <li><a href="#count-el">Поиск количества заданного элемента</a></li>
  <li><a href="#rotate-arr">Поиск элемента в повернутом массиве</a></li>
  <li><a href="#rotate-min-el">Поиск минимального элемента в повернутом массиве</a></li>
  <li><a href="#find-peak">Найти пиковый элемент</a></li>
  <li><a href="#find-square">Найти ближайшее число к квадрату</a></li>
  <li><a href="#find-root">Поиск степени числа</a></li>
  <li><a href="#koko">Коко ест бананы</a></li>
  <li><a href="#bouquets">Минимальное количество дней для изготовления букетов</a></li>
  <li><a href="#smallest">Найти наименьший делитель</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Бинарный поиск — это эффективный алгоритм поиска, который широко применяется в информатике и программировании. В основе этого метода лежит идея последовательного деления данных пополам, что позволяет быстро находить нужный элемент в упорядоченном массиве или списке.</p>

<h2 id="search-el"><span class="attention">Найти</span> элемент в отсортированном массиве</h2>

<p>Рассмотрим решение задачи на поиск элемента в отсортированном массиве.</p>

<p><strong>Например:</strong> [3,4,6,7,9,12,16,17] 7 =&gt; 3</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [3,4,6,7,9,12,16,17]
const target = 7
let low = 0
let high = arr.length - 1
let pos = -1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] === target) {
    pos = mid
    break
  } else if (arr[mid] &gt; target) {
    high = mid - 1
  } else {
    low = mid + 1
  }
}

// Позиция искомого элемента: 3
console.log('Позиция искомого элемента:', pos)</code></pre>
  </div>
</div>

<h3 id="вариант-2">Вариант 2</h3>

<p>Через рекурсию.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [3,4,6,7,9,12,16,17]
const target = 16

// Позиция искомого элемента: 6
console.log('Позиция искомого элемента:', binary(arr, target))

function binary(arr, target) {
  const search = (arr, low, high) =&gt; {
    const mid = Math.floor((low + high) / 2)

    if (low &gt; high) {
      return -1
    }

    if (arr[mid] === target) {
      return mid
    }

    if (arr[mid] &gt; target) {
      high = mid - 1
    } else {
      low = mid + 1
    }

    return search(arr, low, high)
  }

  return search(arr, 0, arr.length - 1)
}</code></pre>
  </div>
</div>

<h2 id="low-bound"><span class="attention">Нахождение</span> нижней границы</h2>

<p>Рассмотрим решение задачи на поиск нижней границы в отсортированном массиве.</p>

<p><strong>Например:</strong> [3,5,5,5,5,8,8,15,19,19] 8 =&gt; 5 позиция</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [3,5,5,5,5,8,8,15,19,19]
const target = 8
let low = 0
let high = arr.length - 1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] &gt;= target) {
    high = mid - 1
  } else {
    low = mid + 1
  }
}

// Нижняя граница: 5
console.log('Нижняя граница:', low)</code></pre>
  </div>
</div>

<h2 id="high-bound"><span class="attention">Нахождение</span> верхней границы</h2>

<p>Рассмотрим решение задачи на поиск верхней границы в отсортированном массиве.</p>

<p><strong>Например:</strong> [3,5,5,5,5,8,8,15,19,19] =&gt; 5 позиция</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [3,5,5,5,5,8,8,15,19,19]
const target = 8
let low = 0
let high = arr.length - 1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] &gt; target) {
    high = mid - 1
  } else {
    low = mid + 1
  }
}

// Верхняя граница: 6
console.log('Верхняя граница:', high)</code></pre>
  </div>
</div>

<h2 id="insert-position"><span class="attention">Поиск</span> позиции для вставки</h2>

<p>Рассмотрим решение задачи на поиск позиции где должен был бы располагаться не достающий элемент.</p>

<p><strong>Например:</strong> [1,2,4,7] 6 =&gt; 3 позиция</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [1,2,4,7]
const target = 6
let low = 0
let high = arr.length - 1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] &gt; target) {
    high = mid - 1
  } else {
    low = mid + 1
  }
}

// 'Пропущенная позиция: 3'
console.log('Пропущенная позиция:', low)</code></pre>
  </div>
</div>

<h2 id="floor-ceil"><span class="attention">Поиск</span> нижней и верхней позиции</h2>

<p>Рассмотрим решение задачи на поиск нижней и верхней позиции где должен был бы располагаться не достающий элемент.</p>

<p><strong>Например:</strong> [10,20,30,40,50] 25 =&gt; [1, 2]</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [10,20,30,40,50]
const target = 25

let low = 0
let high = arr.length - 1

let floor = -1
let ceil = -1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] &gt;= target) {
    high = mid - 1
    ceil = mid
  } else if (arr[mid] &lt;= target) {
    low = mid + 1
    floor = mid
  }
}

// Позиция от / до
console.log('Позиция от / до:', [floor, ceil])</code></pre>
  </div>
</div>

<h2 id="count-el"><span class="attention">Поиск</span> количества заданного элемента</h2>

<p>Рассмотрим решение задачи на поиск количества заданного элемента в массиве.</p>

<p><strong>Например:</strong> [2,4,6,8,8,8,8,8,1,1,13] 8 =&gt; 5</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [2,4,6,8,8,8,8,8,1,1,13] // 1,1,2,4,6,8,8,8,8,13
const target = 8
let result = [-1, -1]

const start = first(arr, target)
if (start !== -1) result = [start, last(arr, target)]

// Количество элементов: 5
console.log('Количество элементов:', count(result))

function first(arr, target) {
  arr.sort((a,b) =&gt; a - b)

  let low = 0
  let high = arr.length - 1
  let result = -1

  while (low &lt;= high) {
    const mid = Math.floor((low + high) / 2)

    if (arr[mid] &gt;= target) {
      result = mid
      high = mid - 1
    } else {
      low = mid + 1
    }
  }

  return result
}

function last(arr, target) {
  arr.sort((a,b) =&gt; a - b)

  let low = 0
  let high = arr.length - 1
  let result = -1

  while (low &lt;= high) {
    const mid = Math.floor((low + high) / 2)

    if (arr[mid] &gt; target) {
      high = mid - 1
    } else {
      result = mid
      low = mid + 1
    }
  }

  return result
}

function count(result) {
  if (result[0] === -1) return 0

  return result[1] - result[0] + 1
}</code></pre>
  </div>
</div>

<h2 id="rotate-arr"><span class="attention">Поиск</span> элемента в повернутом массиве</h2>

<p>Рассмотрим решение задачи на поиск позиции элемента в повернутом массиве.</p>

<p><strong>Например:</strong> [7,8,9,1,2,3,4,5,6] 3 =&gt; 5</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [7,8,9,1,2,3,4,5,6]
const target = 3
let low = 0
let high = arr.length - 1
let res = -1

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] === target) {
    res = mid
    break
  }

  if (arr[low] &lt;= arr[mid]) {
    if (arr[low] &lt;= target &amp;&amp; target &lt;= arr[mid]) {
      high = mid - 1
    } else {
      low = mid + 1
    }
  } else {
    if (arr[mid] &lt;= target &amp;&amp; target &lt;= arr[high]) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }
}

// Позиция элемента: 5
console.log('Позиция элемента:', res)</code></pre>
  </div>
</div>

<h2 id="rotate-min-el"><span class="attention">Поиск</span> минимального элемента в повернутом массиве</h2>

<p>Рассмотрим решение задачи на поиск минимального элемента в повернутом массиве.</p>

<p><strong>Например:</strong> [7,8,0,1,2,3,4,5,6] =&gt; 0</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [7,8,0,1,2,3,4,5,6]
let low = 0
let high = arr.length - 1
let min = arr[0]

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)

  if (arr[low] &lt;= arr[high]) {
    min = Math.min(min, arr[low])
    break
  }

  if (arr[mid] &gt;= arr[low]) {
    min = Math.min(min, arr[low])
    low = mid + 1
  } else {
    min = Math.min(min, arr[mid])
    high = mid - 1
  }
}

// Минимальный элемент: 0
console.log('Минимальный элемент:', min)</code></pre>
  </div>
</div>

<h2 id="find-peak"><span class="attention">Найти</span> пиковый элемент</h2>

<p>Рассмотрим решение задачи на поиск позиции пикового элемента.</p>

<p><strong>Например:</strong> [1,2,3,4,5,6,7,8,5,1] =&gt; 7</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [1,2,3,4,5,6,7,8,5,1]

// Позиция пикового элемента: 7
console.log('Позиция пикового элемента:', find(arr))

function find(arr) {
  let n = arr.length

  if (n === 1) return 0
  if (arr[0] &gt; arr[1]) return 0
  if (arr[n-1] &gt; arr[n-2]) return n - 1

  let low = 1
  let high = n - 2

  while (low &lt;= high) {
    let mid = Math.floor((low + high) / 2)

    if (arr[mid] &gt; arr[mid - 1] &amp;&amp; arr[mid] &gt; arr[mid + 1]) {
      return mid
    } else if (arr[mid] &gt; arr[mid - 1] ) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }

  return -1
}</code></pre>
  </div>
</div>

<h2 id="find-square"><span class="attention">Найти</span> ближайшее число к квадрату</h2>

<p>Рассмотрим решение задачи на поиск ближайшего числа квадрат которого наиболее близок к заданному числу.</p>

<p><strong>Например:</strong> 28 =&gt; 5 так как 5 * 5 = 25</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const n = 28

let low = 1
let high = n

while (low &lt;= high) {
  const mid = Math.floor((low + high) / 2)
  const val = mid * mid

  if (val &lt;= n) {
    low = mid + 1
  } else {
    high = mid - 1
  }
}

// Ближайшее число: 5
console.log('Ближайшее число:', high)</code></pre>
  </div>
</div>

<h2 id="find-root"><span class="attention">Поиск</span> числа степени</h2>

<p>Рассмотрим решение задачи на поиск числа степени.</p>

<p><strong>Например:</strong> X ^ 2 = 16 =&gt; 4 так как 4 ^ 2 = 16</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const n = 2
const m = 16

// Число в степени 2 дает 16: 4
console.log('Число в степени 2 дает 16:', find(n, m))

function find(n, m) {
    let low = 1
    let high = m

    while (low &lt;= high) {
        let mid = Math.floor((low + high) / 2)
        let pow = Math.pow(mid, n)

        if (pow === m) {
            return mid
        } else if (pow &lt; m) {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}</code></pre>
  </div>
</div>

<h2 id="koko"><span class="attention">Коко</span> ест бананы</h2>

<p>Рассмотрим решение задачи на поиск количества бананов которые может съесть обезьяна в час.</p>

<p><strong>Например:</strong> [3,6,11,7] =&gt; 4 банана в час</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [3,6,11,7] // количество бананов
const h = 8 // общее отведенное время на поедание бананов

// Количество бананов в час:
console.log('Количество бананов в час:', koko(arr, h))

function koko(arr, h) {
  let low = 1
  let high = Math.max(...arr)
  let mid = -1

  while(low &lt;= high) {
    mid = Math.floor((low + high) / 2)
    const sum = calculate(arr, mid)

    if (sum &gt; h) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }

  return mid
}

function calculate(arr, max) {
  let sum = 0

  for (let i = 0; i &lt; arr.length; i++) {
    sum += Math.ceil(arr[i] / max)
  }

  return sum
}</code></pre>
  </div>
</div>

<h2 id="bouquets"><span class="attention">Минимальное</span> количество дней для изготовления букетов</h2>

<p>Рассмотрим решение задачи на поиск минимального количества дней для изготовления букетов.</p>

<p><strong>Например:</strong> [7,7,7,7,13,11,12,7] =&gt; на 12 день можно будет сделать 2 букета с 3 розами</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [7,7,7,7,13,11,12,7] // день когда распускается цветок
const m = 2 // букетов
const k = 3 // роз в одном букете

// Букеты можем сделать в день: 12
console.log('Букеты можем сделать в день:', bouquets(arr, m, k))

function bouquets(arr, m, k) {
  let low = Math.min(...arr)
  let high = Math.max(...arr)

  while (low &lt;= high) {
     const mid = Math.floor((low + high) / 2)
     let bouquet = count(mid)

     if (bouquet === m) {
       return mid
     } else if (bouquet &lt; m) {
       low = mid + 1
     } else {
       high = mid - 1
     }
  }

  return -1
}

function count(min) {
  let sum = 0
  let bouquet = 0

  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] &lt;= min) {
      sum++
    } else {
      bouquet += Math.floor(sum / k)
      sum = 0
    }
  }

  bouquet += Math.floor(sum / k)

  return bouquet
}</code></pre>
  </div>
</div>

<h2 id="smallest"><span class="attention">Найти</span> наименьший делитель</h2>

<p>Рассмотрим решение задачи на поиск наименьшего положительного целочисленного делителя, чтобы при делении на него всех элементов данного массива сумма результата деления была меньше или равна заданному пороговому значению.</p>

<p><strong>Например:</strong> [1,2,3,4,5] 8 =&gt; 3</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [1,2,3,4,5]
const threshold = 8

// Наименьший делитель: 3
console.log('Наименьший делитель:', smallest(arr, threshold))

function smallest(arr, threshold) {
  if (arr.length &gt; threshold) return -1

  let low = 1
  let high = Math.max(...arr)

  while (low &lt;= high) {
    const mid = Math.floor((low + high) / 2)

    if (sum(arr, mid) &lt;= threshold) {
      high =  mid - 1
    } else {
      low = mid + 1
    }
  }

  return low
}

function sum(arr, mid) {
  let total = 0

  for (let i = 0; i &lt; arr.length; i++) {
    total += Math.ceil(arr[i] / mid)
  }

  return total
}</code></pre>
  </div>
</div>]]></content><author><name></name></author><category term="dsa" /><category term="циклы" /><category term="массивы" /><category term="бинарный поиск" /><summary type="html"><![CDATA[Рассмотрим решение типовых задачек на бинарный поиск.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Алгоритмы сортировки массива</title><link href="http://localhost:4000/blog/2023-09-12-algoritmy-sortirovki-massiva-dsa.html" rel="alternate" type="text/html" title="Алгоритмы сортировки массива" /><published>2023-09-12T09:16:00+06:00</published><updated>2023-09-12T09:16:00+06:00</updated><id>http://localhost:4000/blog/algoritmy-sortirovki-massiva</id><content type="html" xml:base="http://localhost:4000/blog/2023-09-12-algoritmy-sortirovki-massiva-dsa.html"><![CDATA[<p>Рассмотрим популярные решения для сортировки массива от медленных до быстрых.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#selection">Сортировка выбором</a></li>
  <li><a href="#bubble">Сортировка пузырьком</a></li>
  <li><a href="#insertion">Сортировка вставкой</a></li>
  <li><a href="#shaker">Сортировка шейкерная</a></li>
  <li><a href="#merge">Сортировка слиянием</a></li>
  <li><a href="#quick">Сортировка быстрая</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Сортировка массива - важная операция в программировании, которая позволяет упорядочить элементы в массиве в соответствии с определенным порядком. От быстрой сортировки до сортировки пузырьком, существует множество алгоритмов для достижения этой цели. В этой статье мы рассмотрим различные методы сортировки массивов и их практическое применение.</p>

<h2 id="selection"><span class="attention">Сортировка</span> выбором</h2>

<p>Сортировка выбором - находит минимальный элемент в массиве и перемещает его на начало. Затем он повторяет этот процесс для оставшейся части массива.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', selectionSort(arr))

// O(N^2)
function selectionSort(arr) {
  for (let i = 0; i &lt;= arr.length - 2; i++) {
    for (let j = i + 1; j &lt;= arr.length - 1; j++) {
      if (arr[i] &gt; arr[j]) {
        const temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
      }
    }
  }

  return arr
}</code></pre>
  </div>
</div>

<h2 id="bubble"><span class="attention">Сортировка</span> пузырьком</h2>

<p>Сортировка пузырьком - основывается на сравнении и обмене соседних элементов массива до тех пор, пока весь массив не будет отсортирован.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', bubbleSort(arr))

// O(N^2)
function bubbleSort(arr) {
  for(let i = 0; i &lt; arr.length - 1; i++) {
    let swap = false

    for(let j = 0; j &lt; arr.length - 1 - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        swap = true
      }
    }

    if (!swap) break
  }

  return arr
}</code></pre>
  </div>
</div>

<h2 id="insertion"><span class="attention">Сортировка</span> вставкой</h2>

<p>Сортировка вставкой - по мере прохода по массиву элементы “вставляются” на свои места в уже отсортированной части массива.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', insertionSort(arr))

// O(N^2)
function insertionSort(arr) {
  for(let i = 1; i &lt; arr.length; i++) {
    let j = i

    while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; arr[j]) {
      const temp = arr[j - 1]
      arr[j - 1] = arr[j]
      arr[j] = temp

      j--
    }
  }

  return arr
}</code></pre>
  </div>
</div>

<h2 id="shaker"><span class="attention">Сортировка</span> шейкерная</h2>

<p>Шейкерная сортировка - комбинирует в себе принципы сортировки пузырьком и сортировки вставкой. Этот метод сортировки особенно полезен, когда необходимо упорядочить массив элементов, и он обладает интересной особенностью: движение “вперед-назад”.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', cocktailSort(arr))

// O(N^2)
function cocktailSort(arr) {
  let isSorted = true;
  let begin = 0;
  let end = arr.length - 1;

  while (isSorted) {
    isSorted = false;

    // Проход слева направо
    for (let i = begin; i &lt; end; i++) {
      if (arr[i] &gt; arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        isSorted = true;
      }
    }

    // Если элементы не были перемещены, то массив уже отсортирован
    if (!isSorted) {
      break;
    }

    // Сбрасываем флаг isSorted и двигаем конечный индекс на 1 назад
    isSorted = false;
    end--;

    // Проход справа налево
    for (let i = end - 1; i &gt;= begin; i--) {
      if (arr[i] &gt; arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        isSorted = true;
      }
    }

    // Увеличиваем начальный индекс на 1
    begin++;
  }

  return arr;
}</code></pre>
  </div>
</div>

<h2 id="merge"><span class="attention">Сортировка</span> слиянием</h2>

<p>Сортировка слиянием - это эффективный алгоритм сортировки, основанный на принципе разделения массива на более мелкие части, и последующем их слиянии в упорядоченный массив. Этот алгоритм отличается стабильностью и хорошей производительностью, что делает его важным инструментом для сортировки больших объемов данных.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', mergeSort(arr))

// O(n log n)
function mergeSort(arr) {
  if (arr.length &lt;= 1) {
    return arr;
  }

  let mid = Math.floor(arr.length / 2);
  let left = arr.slice(0, mid);
  let right = arr.slice(mid);

  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];

  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) {
    if (left[leftIndex] &lt; right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  while (leftIndex &lt; left.length) {
    result.push(left[leftIndex])
    leftIndex++
  }

  while (rightIndex &lt; right.length) {
    result.push(right[rightIndex])
    rightIndex++
  }

  return result
}</code></pre>
  </div>
</div>

<h2 id="quick"><span class="attention">Сортировка</span> быстрая</h2>

<p>Быстрая сортировка - это эффективный алгоритм сортировки, который основан на принципе разделения массива на подмассивы, с последующей сортировкой каждого подмассива и их объединением. Этот алгоритм известен своей высокой производительностью и широким применением в различных областях программирования.</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [13, 46, 52, 20, 9]

// Исходный массив: [13,46,52,20,9]
console.log('Исходный массив:', arr)

// Отсортированный массив: [9,13,20,46,52]
console.log('Отсортированный массив', quickSort(arr))

// O(n log n)
function quickSort(arr) {
  if (arr.length &lt;= 1) {
    return arr;
  }

  let pivot = arr[0];
  let left = [];
  let right = [];

  for (let i = 1; i &lt; arr.length; i++) {
    if (arr[i] &lt; pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return quickSort(left).concat(pivot, quickSort(right));
 }</code></pre>
  </div>
</div>]]></content><author><name></name></author><category term="dsa" /><category term="циклы" /><category term="массивы" /><category term="сортировка" /><summary type="html"><![CDATA[Рассмотрим популярные решения для сортировки массива от медленных до быстрых.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Базовая концепция двумерных массивов, решения типовых задач</title><link href="http://localhost:4000/blog/2023-09-10-bazovaya-koncepciya-dvumernyh-massivov-dsa.html" rel="alternate" type="text/html" title="Базовая концепция двумерных массивов, решения типовых задач" /><published>2023-09-10T09:16:00+06:00</published><updated>2023-09-10T09:16:00+06:00</updated><id>http://localhost:4000/blog/bazovaya-koncepciya-dvumernyh-massivov</id><content type="html" xml:base="http://localhost:4000/blog/2023-09-10-bazovaya-koncepciya-dvumernyh-massivov-dsa.html"><![CDATA[<p>Рассмотрим решения базовых задач на манипуляцию с массивом данных.</p>

<!--more-->

<h2 id="оглавление-статьи"><span class="attention">Оглавление</span> статьи</h2>

<ol>
  <li><a href="#intro">Вводная часть</a></li>
  <li><a href="#matrix-zero">Переписать матрицу нулями</a></li>
  <li><a href="#reverse-matrix">Перевернутая матрица</a></li>
  <li><a href="#rotate-90">Повернутая матрица на 90 градусов</a></li>
  <li><a href="#spiral-matrix">Элементы матрицы по спирали</a></li>
</ol>

<h2 id="intro"><span class="attention">Вводная</span> часть</h2>

<p>Массивы - это фундаментальная структура данных в программировании, которая позволяет хранить и организовывать множество элементов одного типа в одной переменной. В этой статье мы рассмотрим решения базовых задач с массивом данных.</p>

<h2 id="matrix-zero"><span class="attention">Переписать</span> матрицу нулями</h2>

<p>Рассмотрим решение задачи на замену 1 на 0 в столбцах и строках пересекающих 0.</p>

<p><strong>Например:</strong><br />
[<br />
  [1,1,1,1],<br />
  [1,0,1,1],<br />
  [1,1,0,1],<br />
  [1,0,0,1]<br />
]<br />
=&gt;<br />
[<br />
  [1,0,0,1],<br />
  [0,0,0,0],<br />
  [0,0,0,0],<br />
  [0,0,0,0]<br />
]</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">let matrix = [
  [1,1,1,1],
  [1,0,1,1],
  [1,1,0,1],
  [1,0,0,1],
]
let col = Array(matrix.length).fill(0)
let row = Array(matrix[0].length).fill(0)

for (let i = 0; i &lt; row.length; i++) {
  for (let j = 0; j &lt; col.length; j++) {
    if (matrix[i][j] === 0) {
      row[i] = 1
      col[j] = 1
    }
  }
}

for (let i = 0; i &lt; row.length; i++) {
  for (let j = 0; j &lt; col.length; j++) {
    if (row[i] || col[j]) {
      matrix[i][j] = 0
    }
  }
}

/*
Новая матрица:
[\
[1,0,0,1],
[0,0,0,0],
[0,0,0,0],
[0,0,0,0]
]
*/
console.log('Новая матрица:', matrix)</code></pre>
  </div>
</div>

<h2 id="reverse-matrix"><span class="attention">Перевернутая</span> матрица</h2>

<p>Рассмотрим решение задачи на переворачивание матрицы.</p>

<p><strong>Например:</strong><br />
[<br />
[1,2,3,4],<br />
[5,6,7,8],<br />
[9,10,11,12],<br />
[13,14,15,16],<br />
]<br />
=&gt;<br />
[<br />
[13,14,15,16],<br />
[9,10,11,12],<br />
[5,6,7,8],<br />
[1,2,3,4]<br />
]</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [
  [1,2,3,4],
  [5,6,7,8],
  [9,10,11,12],
  [13,14,15,16],
]
const res = []

for (let i = 0; i &lt; arr.length; i++) {
  res[i] = Array(arr.length).fill(0)

  for (let j = 0; j &lt; arr.length; j++) {
    res[i][j] = arr[arr.length - 1 - i][j]
  }
}

/*
Перевернутая матрица:
[
[13,14,15,16],
[9,10,11,12],
[5,6,7,8],
[1,2,3,4]
]
*/
console.log('Перевернутая матрица:', res)</code></pre>
  </div>
</div>

<h2 id="rotate-90"><span class="attention">Повернутая</span> матрица на 90 градусов</h2>

<p>Рассмотрим решение задачи на поворачивание матрицы на 90 градусов.</p>

<p><strong>Например:</strong><br />
[<br />
[1,2,3,4],<br />
[5,6,7,8],<br />
[9,10,11,12],<br />
[13,14,15,16],<br />
]<br />
=&gt;<br />
[<br />
[13,9,5,1],<br />
[14,10,6,2],<br />
[15,11,7,3],<br />
[16,12,8,4]<br />
]</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [
  [1,2,3,4],
  [5,6,7,8],
  [9,10,11,12],
  [13,14,15,16],
]

const res = JSON.parse(JSON.stringify(arr))

for (let i = 0; i &lt; arr.length; i++) {
  for (let j = 0; j &lt; arr.length; j++) {
    res[j][i] = arr[arr.length - 1 - i][j]
  }
}

/*
Повернутая матрица на 90 градусов:
[
[13,9,5,1],
[14,10,6,2],
[15,11,7,3],
[16,12,8,4]
]
*/
console.log('Повернутая матрица на 90 градусов:', res)</code></pre>
  </div>
</div>

<h3 id="вариант-2">Вариант 2</h3>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [
  [1,2,3,4],
  [5,6,7,8],
  [9,10,11,12],
  [13,14,15,16],
]

for (let i = 0; i &lt; arr.length; i++) {
  for (let j = i + 1; j &lt; arr.length; j++) {
    const tmp = arr[i][j]
    arr[i][j] = arr[j][i]
    arr[j][i] = tmp
  }
}

let p1 = 0
let p2 = arr.length - 1

while (p1 &lt; p2) {
  const tmp = arr[p1]
  arr[p1] = arr[p2]
  arr[p2] = tmp

  p1++
  p2--
}

/*
Повернутая матрица на 90 градусов:
[
[4,8,12,16],
[3,7,11,15],
[2,6,10,14],
[1,5,9,13]
]
*/
console.log('Повернутая матрица на 90 градусов:', arr)</code></pre>
  </div>
</div>

<h2 id="spiral-matrix"><span class="attention">Элементы</span> матрицы по спирали</h2>

<p>Рассмотрим решение задачи на разворачивание элементов матрицы по спирали.</p>

<p><strong>Например:</strong><br />
[<br />
[1,2,3,4,5,6],<br />
[20,21,22,23,24,7],<br />
[19,32,33,34,25,8],<br />
[18,31,36,35,26,9],<br />
[17,30,29,28,27,10],<br />
[16,15,14,13,12,11],<br />
]<br />
=&gt;<br />
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]</p>

<div class="code-block">
  <div class="code-block__header">
    <div class="code-block__name">JS</div>
    <button class="code-block__button" data-clipboard-action="copy" aria-label="Скопировать в буфер обмена">
      <svg class="code-block__icon" width="12" height="12" aria-hidden="true">
  <use xlink:href="#icon-copy"></use>
</svg>

      <span>Копировать</span>
    </button>
  </div>
  <div class="code-block__content">
    <pre><code class="js">const arr = [
  [1,2,3,4,5,6],
  [20,21,22,23,24,7],
  [19,32,33,34,25,8],
  [18,31,36,35,26,9],
  [17,30,29,28,27,10],
  [16,15,14,13,12,11],
]

let n = arr.length // row
let m = arr[0].length // col

let left = 0
let right = m - 1

let top = 0
let bottom = n - 1

const res = []

while(top &lt;= bottom &amp;&amp; left &lt;= right) {
  // right
  for (let i = left; i &lt;= right; i++) {
    res.push(arr[top][i])
  }

  top++

  // bottom
  for (let i = top; i &lt;= bottom; i++) {
    res.push(arr[i][right])
  }

  right--

  // left
  for (let i = right; i &gt;= left; i--) {
    res.push(arr[bottom][i])
  }

  bottom--

  // top
  for (let i = bottom; i &gt;= top; i--) {
    res.push(arr[i][left])
  }

  left++
}

// Разворачивание элементов матрицы: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]
console.log('Разворачивание элементов матрицы:', res)</code></pre>
  </div>
</div>]]></content><author><name></name></author><category term="dsa" /><category term="циклы" /><category term="массивы" /><summary type="html"><![CDATA[Рассмотрим решения базовых задач на манипуляцию с массивом данных.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/cover.jpg" /><media:content medium="image" url="http://localhost:4000/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>